## 一、 环境和运行机制、系统调用 (30 分)

1.  请列举五条需要在保护模式下运行的指令。"访管指令"需要在保护模式下执行吗？为什么？ (10 分)

   需要在保护模式下运行的指令：LGDT（加载全局描述符表寄存器）、LIDT（加载中断描述符表寄存器）、MOV CR0（修改控制寄存器）、CLI（清中断标志）、LTR（加载任务寄存器）。
   
   访管指令必须在保护模式下执行。因为访管指令涉及特权级转换，需要保护模式提供的特权级机制来确保安全，实模式下无法提供这种保护。

2.  描述从接收中断/异常到中断处理程序运行结束，处理中断/异常的过程，并指出哪些是硬件实现的？哪些是操作系统实现的？中断处理程序执行结束后，需要执行哪一个模块（哪一过程）？操作系统初始化和中断有什么关系？ (10 分)

   处理中断/异常的过程：
   1. 硬件保存当前上下文（保存标志寄存器、CS、IP等）
   2. 硬件根据中断向量查找IDT，获取中断处理程序入口地址
   3. 硬件切换到内核态，跳转到中断处理程序
   4. 操作系统保存其他现场（寄存器等）
   5. 操作系统执行具体中断处理程序
   6. 操作系统恢复现场
   7. 硬件执行IRET指令，恢复标志寄存器、CS、IP等，返回被中断的程序

   硬件实现：1-3和7步骤；操作系统实现：4-6步骤。
   
   中断处理程序结束后执行中断返回例程。
   
   操作系统初始化需要设置中断描述符表，初始化中断控制器，为系统提供中断处理的基础设施。

3.  为了实现系统调用机制，系统要做哪些工作？ (10 分)

   实现系统调用机制需要：
   1. 定义系统调用接口和编号
   2. 实现用户态到内核态的特权级切换（通常通过软中断实现）
   3. 提供系统调用表，将调用编号映射到对应的内核函数
   4. 实现参数传递机制（通过寄存器或栈）
   5. 实现返回值传递机制
   6. 提供用户库封装系统调用（如libc）
   7. 实现权限检查和安全控制

## 二、 进程线程模型 (20 分)

1.  请画出五状态进程模型，包括状态的名称以及转移条件。 (10 分)

   五状态进程模型：
   - 新建（New）：进程刚被创建
   - 就绪（Ready）：进程等待被调度
   - 运行（Running）：进程正在执行
   - 阻塞（Blocked）：进程等待某事件发生
   - 终止（Terminated）：进程执行完毕

   状态转移：
   - 新建→就绪：进程创建完成，系统接纳
   - 就绪→运行：调度器选择执行
   - 运行→就绪：时间片用完或高优先级进程抢占
   - 运行→阻塞：进程等待资源或I/O操作
   - 阻塞→就绪：等待事件发生或资源可用
   - 运行→终止：进程执行完毕或被强制终止

2.  线程和进程有什么区别？线程有什么属性？为什么线程要有自己的栈？线程的实现方式有哪几种？典型的操作系统是通过什么方式实现线程的？ (10 分)

   区别：
   - 进程是资源分配的基本单位，线程是CPU调度的基本单位
   - 同一进程内的线程共享地址空间和资源，进程间相互独立
   - 线程切换开销小于进程切换
   - 线程没有独立的地址空间，进程有

   线程属性：线程ID、程序计数器、寄存器集合、栈、状态、优先级

   线程需要自己的栈是因为：每个线程执行不同的函数调用序列，需要独立的栈来保存局部变量、返回地址和函数参数，确保函数调用的正确执行。

   线程实现方式：用户级线程（在用户空间实现）、内核级线程（在内核中实现）、混合实现（两种方式结合）。

   典型操作系统通过内核级线程实现线程机制，如Windows、Linux等。

## 三、 进程调度 (25 分)

1.  现在有三个进程，A、B 和 C。A 和 B 的运行时间是 1000ms（全部在 CPU 上进行计算），C 进程是一个无限循环，在每个循环中，会先使用处理器 1ms，然后再花 10ms 使用 I/O。请写出在以下几种调度算法下进程的调度状态，并对每个调度算法对本任务的调度进行分析和评价。调度算法分别为：先来先服务算法、时间片轮转算法（时间片分别为 100ms 和 1ms）、SRTN（最短剩余时间优先算法）。 (10 分)

   先来先服务(FCFS)：
   假设顺序为A→B→C
   - A运行1000ms完成
   - B运行1000ms完成
   - C无限循环运行
   
   评价：A、B进程有固定完成时间，但C的响应性很差，要等待2000ms才能首次运行。对I/O密集型进程不友好。

   时间片轮转(RR)，时间片=100ms：
   - A运行100ms，还剩900ms
   - B运行100ms，还剩900ms
   - C运行1ms后进入I/O等待
   - I/O过程中可调度A、B
   - 以此类推

   评价：公平性好，A和B需要20轮才能完成，总完成时间约为2000ms。C获得较好响应性。

   时间片轮转(RR)，时间片=1ms：
   - A运行1ms，还剩999ms
   - B运行1ms，还剩999ms
   - C运行1ms后进入I/O等待
   - 循环往复
   
   评价：频繁切换造成巨大开销，但C进程响应性最佳，可以充分利用I/O和CPU并行。

   SRTN：
   - C的CPU时间短(每次1ms)，优先运行C
   - C执行后I/O时，A和B竞争
   - 当A和B剩余时间相等时，随机选择
   
   评价：C获得最好的响应性，但A和B可能出现饥饿，因为C无限循环。

2.  请设计一个基于多级反馈队列的调度算法，描述你的算法并回答以下问题： (15 分)
    (1) 你设计的算法是抢占的还是非抢占的？为什么？
    (2) 你设计的算法对 I/O 密集型和 CPU 密集型进程哪个更友好？说明你的原因。
    (3) 你是如何处理进程等待 I/O 后再次被调度上 CPU 时要继续运行的时间片大小的？
    (4) 你设计的算法会导致"饥饿"问题吗？为什么会有这个问题？如果产生了"饥饿"的问题，要用什么方法解决？

   多级反馈队列调度算法设计：
   - 设置三个队列：Q0、Q1、Q2，优先级依次降低
   - Q0时间片为4ms，Q1为8ms，Q2为16ms
   - 新进程先进入Q0
   - 进程在当前队列未用完时间片时被抢占，重新排队
   - 用完时间片的进程进入下一级队列
   - 最后一级队列(Q2)采用FCFS策略
   - 每隔100ms将所有进程重新放入Q0
   
   (1) 该算法是抢占式的。因为新进入高优先级队列的进程可以抢占低优先级队列中运行的进程，提高系统响应性和交互性能。
   
   (2) 该算法对I/O密集型进程更友好。I/O密集型进程通常在短时间内就会因等待I/O而主动放弃CPU，未用完时间片，当它们的I/O完成后，会重新进入高优先级队列，获得更高的调度优先权；而CPU密集型进程通常会用完时间片，逐渐降到低优先级队列。
   
   (3) 最高优先级进程等待I/O后再次被调度上CPU时，会进入最高优先级队列(Q0)，重新获得短时间片。这样设计是因为刚完成I/O的进程可能立即需要CPU进行处理，赋予较高优先级可提高系统吞吐量。
   
   (4) 该算法可能导致饥饿问题。CPU密集型进程可能被持续推至最低优先级队列，而频繁的I/O操作进程一直占据高优先级队列。解决方法是定期将所有进程提升到最高优先级队列（已在算法中设计为每100ms一次），确保每个进程都有公平的执行机会。

## 四、 进程同步 (25 分)

1.  不同的操作系统为实现进程同步提供了不同的机制。锁和条件变量的机制分别能解决什么问题？如果用锁和条件变量来解决生产者-消费者问题，需要注意哪一点？ (5 分)

   锁能解决互斥访问问题，确保同一时间只有一个线程可以访问共享资源，防止并发访问导致的数据不一致。

   条件变量能解决线程间同步和通信问题，允许线程等待某个条件满足，并在条件满足时被其他线程唤醒。
   
   使用锁和条件变量解决生产者-消费者问题时，需要注意在检查条件和执行后续操作之间可能发生的"虚假唤醒"，应使用while循环而非if语句检查条件；同时要避免死锁，确保锁的获取和释放正确配对。

**以下 2、3、4 三道用信号量和 PV 操作解决的问题中，任选一道题进行作答。如果多选，按所答的第一道题评分。**

2.  (10 分) 邱德拔体育馆内有一个羽毛球场地，供若干学生练习羽毛球。现在是双打练习时间，每四个学生组成一队，占用球场练习。
    **要求：**
    如果不足四个学生，则不能开展双打练习；如果四个学生练习了足够时间，则一起离开球场，此时，可以让其他等待的学生利用羽毛球场地进行练习。
    体育教研室会安排一个裁判进行评分（没有学生练习，裁判在休息室休息）。
    请用信号量及 PV 操作正确完成羽毛球场地的使用过程。

   ```c
   // 信号量定义
   semaphore mutex = 1;         // 互斥访问共享变量
   semaphore court = 0;         // 表示球场是否可用
   semaphore players = 0;       // 用于计数凑齐四个学生
   semaphore referee = 0;       // 通知裁判开始工作
   semaphore judge_done = 0;    // 裁判评分完成信号
   int waiting = 0;             // 等待的学生数量
   
   // 学生进程
   void student() {
       while(true) {
           P(mutex);
           waiting++;
           if(waiting == 4) {   // 第四个学生到达时
               waiting = 0;     // 重置等待计数
               V(players);      // 通知可以开始比赛
           }
           V(mutex);
           
           P(players);          // 等待凑齐四人
           
           // 四个人一起进入球场
           P(mutex);
           if(waiting == 0) {   // 第一组学生或前一组已完全离开
               V(referee);      // 通知裁判
           }
           V(mutex);
           
           // 练习羽毛球
           practice_badminton();
           
           P(judge_done);       // 等待裁判评分完成
           
           P(mutex);
           // 四人一起离开球场
           V(court);           // 释放球场
           V(mutex);
       }
   }
   
   // 裁判进程
   void referee_process() {
       while(true) {
           P(referee);         // 等待学生通知
           
           judge_game();       // 对比赛进行评分
           
           // 通知所有4个学生评分完成
           for(int i = 0; i < 4; i++) {
               V(judge_done);
           }
       }
   }
   ```

   信号量作用：
   - mutex：保护共享变量，确保互斥访问
   - court：表示球场是否可用
   - players：用于学生等待凑齐四人
   - referee：通知裁判开始工作
   - judge_done：裁判评分完成的信号
   - waiting：记录正在等待的学生数量

3.  (10 分) 现在有一条河南有南北两岸，河上有 N 个石墩，每个石墩上只能有一个人，要求在过河时只能有单向的人过河（类似于三峡大坝问题，具体记不清了）。
    (1) 使用信号量和 PV 操作正确解决这个问题。
    (2) 如果从南边来的人多，要求优先满足南边的人的过河需求，应该做怎样的改动？

   (1) 基本解决方案：
   ```c
   // 信号量定义
   semaphore mutex = 1;           // 保护共享变量访问
   semaphore direction = 1;       // 控制过河方向
   semaphore stones[N];           // 每个石墩的信号量，初值为1
   int current_dir = 0;           // 当前方向：0表示南到北，1表示北到南
   int count = 0;                 // 正在过河的人数
   
   // 南岸到北岸过河
   void south_to_north(int id) {
       P(mutex);
       if(current_dir == 1 && count > 0) {  // 如果当前方向相反且有人过河
           V(mutex);
           P(direction);                     // 等待方向改变
       } else {
           current_dir = 0;                  // 设置当前方向为南到北
           count++;
           V(mutex);
       }
       
       // 过河过程，依次占用石墩
       for(int i = 0; i < N; i++) {
           P(stones[i]);           // 占用第i个石墩
           // 移动到第i个石墩
           if(i > 0) {
               V(stones[i-1]);     // 离开第i-1个石墩
           }
       }
       
       // 到达北岸
       V(stones[N-1]);            // 离开最后一个石墩
       
       P(mutex);
       count--;
       if(count == 0) {           // 如果没有人过河了
           V(direction);          // 允许改变方向
       }
       V(mutex);
   }
   
   // 北岸到南岸过河（逻辑类似，方向相反）
   void north_to_south(int id) {
       P(mutex);
       if(current_dir == 0 && count > 0) {
           V(mutex);
           P(direction);
       } else {
           current_dir = 1;
           count++;
           V(mutex);
       }
       
       // 过河过程，反向占用石墩
       for(int i = N-1; i >= 0; i--) {
           P(stones[i]);
           if(i < N-1) {
               V(stones[i+1]);
           }
       }
       
       // 到达南岸
       V(stones[0]);
       
       P(mutex);
       count--;
       if(count == 0) {
           V(direction);
       }
       V(mutex);
   }
   ```

   信号量作用：
   - mutex：保护共享变量的互斥访问
   - direction：控制过河方向的改变
   - stones[N]：表示每个石墩是否被占用
   - current_dir：记录当前过河方向
   - count：记录正在过河的人数

   (2) 优先满足南边的人：
   ```c
   // 新增信号量
   semaphore south_prio = 1;      // 南边人优先信号量
   int south_waiting = 0;         // 南边等待的人数
   
   // 修改南岸到北岸函数
   void south_to_north(int id) {
       P(south_prio);             // 获取南边优先权
       south_waiting++;
       V(south_prio);
       
       // 原来的逻辑
       P(mutex);
       if(current_dir == 1 && count > 0) {
           V(mutex);
           P(direction);
       } else {
           current_dir = 0;
           count++;
           V(mutex);
       }
       
       P(south_prio);
       south_waiting--;
       if(south_waiting == 0) {   // 如果没有南边的人等待了
           V(south_prio);         // 释放优先权
       } else {
           V(south_prio);         // 保持优先权
       }
       
       // 石墩过河逻辑不变
       // ...
   }
   
   // 修改北岸到南岸函数
   void north_to_south(int id) {
       P(south_prio);             // 检查是否有南边的人优先
       if(south_waiting > 0) {    // 如果有南边的人等待
           V(south_prio);         // 释放优先权给南边的人
           P(south_prio);         // 等待南边人都过完河
       } else {
           V(south_prio);         // 没有南边的人，继续
       }
       
       // 原来的逻辑
       // ...
   }
   ```

   新增信号量作用：
   - south_prio：控制南边人的优先权
   - south_waiting：记录南边等待的人数

4.  (10 分) 有一个系统，定义 P、V 操作如下：

    ```
    P(s):
        s.count--;
        if s<0 then
            将本进程插入相应队列末尾等待;

    V(s):
        s.count++;
        if s<=0 then
            从相应等待队列队尾唤醒一个进程，将其插入就绪队列;
    ```

    (1) 这样定义的 PV 操作会导致什么样的问题？
    (2) 用这样的 PV 操作正确实现 8 个进程访问临界区的互斥机制。
    (3) 对于 (2) 中的问题，请设计一个复杂度更低的解法。

   (1) 这种定义的PV操作会导致的问题：
   - 公平性问题：V操作从队尾唤醒进程，不符合先等待先服务原则
   - 可能导致进程饥饿：某些进程可能长时间无法获得资源
   - 不支持优先级调度：无法基于进程优先级进行调度
   - 互斥语义变化：与传统PV操作的互斥效果不同

   (2) 实现8个进程互斥访问临界区：
   ```c
   // 信号量定义
   semaphore mutex = 8;  // 初始值设为进程数
   
   // 进程访问临界区
   void process(int id) {
       while(true) {
           P(mutex);  // 尝试进入临界区
           
           // 临界区
           critical_section();
           
           V(mutex);  // 离开临界区
           
           // 非临界区
           non_critical_section();
       }
   }
   ```

   这个解决方案中，互斥信号量初值设为8，表示最多允许8个进程同时访问临界区。由于题目要求的是互斥访问，我们需要确保一次只有一个进程在临界区，但此处的PV操作语义特殊，需要特别处理。

   (3) 复杂度更低的解法：
   ```c
   // 信号量定义
   semaphore mutex = 1;  // 初始值为1
   
   // 进程访问临界区
   void process(int id) {
       while(true) {
           P(mutex);  // 尝试进入临界区
           
           // 临界区
           critical_section();
           
           V(mutex);  // 离开临界区
           
           // 非临界区
           non_critical_section();
       }
   }
   ```

   这个解法使用标准互斥信号量，初值为1，确保一次只有一个进程能访问临界区，复杂度更低，更容易理解和验证正确性。

5.  用管程模拟顾客进出超市的问题：(10 分)
    某物美超市有 100 辆购物推车，顾客进入时要刷会员卡领取一辆推车，如果超市没有空闲推车，则顾客在超市门口等待。顾客买完东西结账离开时需刷卡还回推车。

   ```c
   monitor Supermarket {
       // 变量定义
       int free_carts = 100;  // 空闲购物车数量
       condition cart_available;  // 条件变量：有空闲购物车
       
       // 顾客获取购物车
       void get_cart() {
           if (free_carts == 0) {
               // 没有空闲购物车，等待
               wait(cart_available);
           }
           free_carts--;  // 减少一辆空闲购物车
       }
       
       // 顾客归还购物车
       void return_cart() {
           free_carts++;  // 增加一辆空闲购物车
           
           // 通知等待购物车的顾客
           signal(cart_available);
       }
   }
   
   // 顾客进程
   void customer(int id) {
       // 获取购物车
       Supermarket.get_cart();
       
       // 购物
       shopping();
       
       // 结账并归还购物车
       checkout();
       Supermarket.return_cart();
   }
   ```

   变量和条件变量作用：
   - free_carts：记录当前可用的购物车数量，初始值为100
   - cart_available：条件变量，表示有空闲购物车可用

**解答 PV 及管程题目的注意事项：**
1.  说明每一个信号量、条件变量或变量的作用；
2.  对代码的重点语句给予注释。

## 附加题：(6 分)

请描述一个现实生活中遇到的 IPC (进程间通信) 问题的场景，要求不与已经见到过的 IPC 问题的场景重复。

现实生活中的IPC场景：智能家居系统控制

在一个智能家居系统中，多个独立的控制程序（相当于进程）需要协同工作：
- 温度监控进程收集传感器数据并发送给中央控制系统
- 照明控制进程管理家中灯光
- 安全监控进程检测异常并发送警报
- 用户界面进程接收用户指令

这些进程需要高效通信以确保系统协调运行。例如，当用户通过手机APP（用户界面进程）调整温度设置时，该指令需要传递给温度控制进程；当安全监控检测到异常，需要通知照明控制打开所有灯光并通知用户界面显示警报。

这种场景可通过消息队列实现进程间通信，各进程订阅相关主题，实现去中心化的事件驱动架构。与传统生产者-消费者或读写者问题不同，这是一个多对多的通信模型，各进程既可能是信息生产者也可能是消费者，通信关系更为复杂。
