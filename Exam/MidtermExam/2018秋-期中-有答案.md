## 一、 关于CPU状态 (8分)

1.  为什么要将指令集合划分为不同的特权级别?

    **答**: 将指令集划分为不同特权级别是为了保护系统安全和稳定运行。高特权级(内核态)执行关键操作，低特权级(用户态)执行普通应用程序，防止用户程序直接访问硬件资源或执行危险操作，避免系统崩溃和安全漏洞。

2.  下列指令哪些指令只能在内核态（管态）下执行? (请在你要选择的指令上划勾)
    算术运算、内存读写、读日期时间、启动I/O、修改程序状态字、访管指令、陷入指令(如sysenter)、允许/禁止中断、取数指令
    
    **答**: 只能在内核态下执行的指令：启动I/O、修改程序状态字、允许/禁止中断。

## 二、 关于中断、异常和系统调用 (15分)

1.  在实现系统调用时, 需要硬件体系结构提供哪些支持? 在操作系统中应完成哪些工作? 请以 IA32 体系结构为例, 描述执行系统调用时硬件和软件的工作流程。
    (可以参考考图1给出的IA32体系结构中相关的信息。涉及到的寄存器包括: EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP等。)

    **中断描述符格式**
    | 段选择符(高16位) |  DPL  |   P   | 门类型 |  D00  | 空闲  | 段选择符 | 段内偏移(低16位) |

    * IDTR -> IDT
    * GDTR -> GDT

    **图 1 IA32 体系结构中相关信息**

    **段描述符格式**
    | 段基址 | 段界限 | 属性(包括DPL) | 段基址 |
    | :----: | :----: | :-----------: | :----: |

    **答**: 硬件支持：特权级机制、中断门机制、寄存器保存现场。IA32提供特殊指令(如int、sysenter)、IDT和GDT表、特权级切换机制。
    
    操作系统工作：系统调用表维护、参数传递接口、内核态处理逻辑实现。
    
    工作流程：用户程序将系统调用号放入EAX，参数放入其他寄存器(EBX/ECX/EDX等)，执行int 0x80指令；CPU检查特权级，切换到内核态，保存现场；根据IDTR找到IDT，根据中断号找到对应处理程序；系统调用处理程序从EAX获取调用号，从寄存器获取参数；执行内核服务；返回用户态，通过EAX返回结果。

2.  系统调用与函数调用有什么区别? 系统调用与API是什么关系?

    **答**: 系统调用与函数调用区别：系统调用涉及特权级切换(用户态→内核态)，函数调用在同一特权级；系统调用使用特殊指令(如int 0x80)，函数调用使用call指令；系统调用开销较大，需保存更多现场信息。
    
    系统调用与API关系：API是应用程序编程接口，为应用程序提供标准化功能；系统调用是操作系统内核提供的服务；API通常封装了系统调用，提供更友好的接口，一个API可能涉及多个系统调用。

## 三、 关于进程线程模型 (18分)

1.  进程控制块(PCB) 的作用是什么? 它与进程控制操作(创建、撤销、阻塞、唤醒)的关联是什么? 它与进程切换的关联是什么? 它与进程调度的关联是什么? 它是怎么描述进程地址空间的?

    **答**: PCB作用：记录进程状态信息，是进程存在的唯一标志，包含进程标识、状态、优先级、程序计数器、寄存器值、内存信息等。
    
    与进程控制操作关联：创建进程时分配PCB并初始化；撤销时回收PCB及资源；阻塞/唤醒时修改PCB状态字段。
    
    与进程切换关联：进程切换时保存当前进程寄存器等上下文信息到PCB，并从下一进程PCB恢复上下文；PCB是上下文切换的核心数据结构。
    
    与进程调度关联：调度器根据PCB中优先级、状态等信息决定调度顺序；PCB中包含调度所需的时间片、优先级等信息。
    
    描述地址空间：PCB记录进程页表基址或段表基址；记录代码段、数据段、堆栈段等内存区域信息；维护虚拟地址到物理地址的映射关系。

2.  操作系统对用户级线程和内核级线程的支持有什么不同点? 各列举一个支持用户级线程和内核级线程的实例操作系统名字。

    **答**: 用户级线程由用户空间线程库管理，内核不感知；切换开销小但一个线程阻塞会导致整个进程阻塞；无法利用多处理器。
    
    内核级线程由内核直接支持和管理；线程阻塞不影响其他线程；可利用多处理器；切换开销较大。
    
    支持用户级线程的系统：早期的Solaris(Green Threads)
    支持内核级线程的系统：Linux(NPTL)

## 四、 关于进程调度 (18分)

1.  应用哪一种进程调度算法会导致优先级反转(置)问题? 请举例描述"优先级反转(置)"的现象。如何解决这一问题?

    **答**: 优先级调度算法(尤其是抢占式优先级调度)会导致优先级反转问题。
    
    现象：低优先级进程L持有某资源，高优先级进程H需要该资源而被阻塞，但中优先级进程M可以继续执行，间接导致优先级H < M，违反原本优先级设计。
    
    解决方法：优先级继承(低优先级进程临时继承被阻塞的高优先级进程的优先级)；优先级天花板(持有资源时提升到可能访问该资源的最高优先级)；避免共享资源(使用无锁算法或复制资源)。

2.  请叙述多级反馈队列调度算法的设计思想。请说明这一设计是如何处理 I/O 密集型和 CPU 密集型进程的? 这一设计是否会带来"饥饿"问题? 如何解决这一问题?

    **答**: 多级反馈队列设计思想：根据进程行为动态调整优先级；设置多个就绪队列，不同队列优先级和时间片不同；新进程先进入高优先级队列，用完时间片后降级；优先调度高优先级队列进程。
    
    对I/O密集型和CPU密集型处理：I/O密集型进程在I/O操作前往往用不完时间片即主动让出CPU，下次调度时仍在高优先级队列；CPU密集型进程会用完时间片被降级到低优先级队列，减少对系统的影响。
    
    饥饿问题：高优先级队列任务过多时，低优先级队列任务可能长时间得不到执行。
    
    解决方法：设置老化机制(等待时间超过阈值自动提升优先级)；定期将所有进程重新放入最高优先级队列；保证每个队列都有最小执行时间份额。

## 五、 关于同步互斥机制 (5分)

针对单处理器和多处理器, 请说明自旋锁(忙等锁)的优势和劣势。
    **答**: 单处理器环境：
    优势：实现简单；无需上下文切换，对于锁竞争少且临界区短的情况效率高。
    劣势：忙等浪费CPU资源；单处理器上一个线程自旋时，持有锁的线程无法执行，可能导致死锁；适用场景有限。

    多处理器环境：
    优势：避免上下文切换开销；临界区短时效率高；适合多核处理器并行执行。
    劣势：多线程争用激烈时浪费处理器资源；需要硬件原子操作支持；可能导致缓存一致性问题。

## 六、 综合题 (17分)

1.  假设一个用户在命令行执行了程序 A, A 在执行过程中需要调用系统调用 read 到磁盘上读数据。又假设调度程序选择的下一个要执行的是进程 Z。请叙述从用户在命令行输入执行程序 A 的命令, 到系统执行完程序 A 的全过程。

    **答**: 用户在命令行输入程序A名称并回车；shell进程执行fork创建子进程；子进程通过exec加载程序A；程序A开始执行，初始化环境；执行read系统调用读取磁盘数据；CPU从用户态切换到内核态；内核验证参数，查找文件；发起磁盘I/O请求；由于I/O操作耗时，内核将进程A状态改为阻塞；调度器选择进程Z运行；磁盘读取完成后产生中断；中断处理程序将数据复制到A的缓冲区；将进程A状态改为就绪；当进程A再次获得CPU时，从系统调用返回点继续执行；进程A完成所有操作后调用exit退出；父进程(shell)接收到子进程退出信号，回收子进程资源。

2.  设计操作系统时要对"时间与空间"、"公平与性能"进行权衡, 请各举一个例子进行说明。

    **答**: 时间与空间权衡：分页系统中页面大小的选择。小页面节省内存空间(减少内部碎片)但增加页表开销和换页频率；大页面减少页表开销但可能增加内存浪费。操作系统设计者需根据系统特性选择合适页面大小。
    
    公平与性能权衡：进程调度算法选择。时间片轮转算法公平性好但上下文切换开销大；优先级调度性能高但可能导致低优先级进程饥饿。现代操作系统常采用多级反馈队列等混合算法在公平性和性能间寻求平衡。

**解答 PV 及管程题目时注意事项:**
*   1、说明每一个信号量、条件变量或变量的作用;
*   2、对代码的重点语句给予注释。

## 七、 关于信号量及 P、V 操作 (12分)

1.  假设有一座南北向的桥, 桥上只能单方向通行车辆。又假设该桥最大可载重 5 辆汽车。请用信号量及 PV 操作正确实现车辆过桥的程序。

    **答**: 
    ```c
    // 定义信号量
    semaphore bridge_direction = 1;  // 控制桥上车辆方向，初值1表示桥空闲
    semaphore capacity = 5;          // 控制桥的载重量，最多5辆车
    int north_count = 0;             // 记录北向车辆数量
    int south_count = 0;             // 记录南向车辆数量
    semaphore mutex = 1;             // 保护计数器的互斥访问
    
    // 北向车辆过桥
    void north_car() {
        while(1) {
            P(mutex);
            if(south_count == 0) {   // 如果没有南向车辆
                north_count++;       // 增加北向车辆计数
                if(north_count == 1) // 第一辆北向车
                    P(bridge_direction); // 占用桥的方向为北向
                V(mutex);
                
                P(capacity);         // 占用一个车位
                
                // 过桥...
                
                V(capacity);         // 释放一个车位
                
                P(mutex);
                north_count--;       // 减少北向车辆计数
                if(north_count == 0) // 最后一辆北向车
                    V(bridge_direction); // 释放桥的方向控制
                V(mutex);
            } else {
                V(mutex);            // 有南向车辆，等待后重试
            }
        }
    }
    
    // 南向车辆过桥（与北向对称）
    void south_car() {
        // 逻辑与north_car()类似，只是操作south_count
    }
    ```

2.  邱德拔体育馆内设有一个羽毛球场地, 供若干个学生练习打羽毛球。假设现在是双打练习时间, 每四个学生组成一队, 占用球场练习。
    **要求:**
    如果不足四个学生, 则不能正式开展双打练习; 如果四个学生练习了足够时间, 则一起离开让出球场, 此时, 可以让其他等待的学生利用羽毛球场地进行练习。
    体育教研室会安排一个裁判进行评分(没有学生练习，裁判在休息室休息)。
    请用信号量及 P、V 操作正确完成羽毛球场地的使用过程。

    **答**: 
    ```c
    // 定义信号量和变量
    semaphore court = 1;            // 控制球场使用权，初值1表示空闲
    semaphore students_ready = 0;   // 就绪的学生数量，初值0
    semaphore judge_needed = 0;     // 需要裁判信号，初值0
    semaphore judge_ready = 0;      // 裁判就绪信号，初值0
    semaphore mutex = 1;            // 互斥访问计数器
    int waiting_count = 0;          // 等待的学生数量
    
    // 学生进程
    void student() {
        P(mutex);
        waiting_count++;            // 增加等待学生计数
        
        if(waiting_count == 4) {    // 凑够4人可以开始比赛
            P(court);               // 占用球场
            V(judge_needed);        // 通知裁判
            P(judge_ready);         // 等待裁判就绪
            
            // 释放4个学生进入场地
            for(int i = 0; i < 4; i++)
                V(students_ready);
                
            waiting_count -= 4;     // 减少等待计数
        }
        V(mutex);
        
        P(students_ready);          // 等待进入球场信号
        
        // 进行双打练习...
        
        // 练习结束离开
        // 假设4人一起离开，由最后一人负责
        // 实际中需要额外同步机制确保同时离开
        
        // 如果是最后离开的学生
        V(court);                   // 释放球场
    }
    
    // 裁判进程
    void judge() {
        while(1) {
            P(judge_needed);        // 等待需要裁判的信号
            // 前往球场
            V(judge_ready);         // 通知学生裁判已就绪
            
            // 进行评分...
            
            // 学生离开后裁判回休息室
        }
    }
    ```

## 八、 关于管程 (7分)

某超市共有 200 辆购物推车, 顾客进入时要先在门口用会员卡换取一辆推车。若超市没有空闲推车, 则顾客不能进入超市, 在超市门口处等候。顾客购买完东西结账离开时要换回自己的会员卡。请用管程正确实现顾客进出超市的问题。

    **答**: 
    ```c
    monitor Supermarket {
        int carts = 200;                 // 可用购物车数量，初始为200
        condition cart_available;        // 条件变量：有可用购物车
        
        // 顾客进入超市
        void enter() {
            if(carts <= 0)               // 没有可用推车
                wait(cart_available);    // 等待推车可用
            
            carts--;                     // 占用一辆推车
        }
        
        // 顾客离开超市
        void leave() {
            carts++;                     // 归还一辆推车
            signal(cart_available);      // 通知等待推车的顾客
        }
    }

    // 顾客进程
    void customer() {
        Supermarket.enter();             // 尝试进入超市
        
        // 购物过程...
        
        Supermarket.leave();             // 离开超市，归还推车
    }
