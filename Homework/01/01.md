# 操作系统作业 1 —— 启动与中断异常部分

<center><div style='height:2mm;'></div><div style="font-size:10pt;">梁昱桐 2100013116</div></center>
<center><span style="font-size:9pt;line-height:9mm"><i>Peking University</i></span>
</center>

## 中断响应流程

**问题**：复习课件 2-中断异常机制，回答中断响应流程部分的练习题：理解 Linux 的中断处理流程，解释为什么引⼊上半部和下半部处理。

**回答**：

Linux 的中断处理流程主要包括以下步骤：
1. 硬件设备触发中断，产生中断信号
2. CPU 检测到中断信号，暂停当前执行的程序
3. CPU 根据中断向量找到对应的中断服务例程（ISR）
4. 保存当前执行上下文（寄存器状态等）
5. 跳转到中断服务例程执行中断处理
6. 执行结束后恢复上下文，继续执行被中断的程序

Linux 引入上半部（Top Half）和下半部（Bottom Half）处理机制的原因：

1. **实时性要求**：中断处理需要快速响应，但完整的中断处理可能耗时较长。上半部负责紧急且必须立即完成的工作，下半部负责可以延迟处理的工作。

2. **减少中断屏蔽时间**：上半部执行时通常会屏蔽中断，如果所有中断处理都在上半部完成，会导致较长时间无法响应其他中断，降低系统响应能力。

3. **提高系统并发性**：将耗时操作放在下半部处理，允许系统在此期间处理其他任务，提高系统整体吞吐量。

4. **资源竞争管理**：下半部可以采用不同的同步机制，更合理地管理对共享资源的访问。

Linux 中实现下半部机制的方式主要有 softirq、tasklet 和工作队列（work queue）等。

## 国产操作系统调研

**问题**：调研并简要总结两个典型的国产操作系统：麒麟、鸿蒙、OpenEuler、统信等。允许使⽤ ChatGPT、DeepSeek 等⼤模型；若使⽤，请说明使⽤的是哪⼀个，并在作业中给予评价或⾃⼰的⻅解。

**回答**：

### 麒麟操作系统（Kylin OS）

麒麟操作系统是中国自主研发的操作系统，由中国国防科技大学于2001年开始研发，现由麒麟软件有限公司负责开发和维护。

**主要特点**：
- 基于 Linux 内核开发，支持国产 CPU 架构（如龙芯、飞腾等）
- 面向服务器、桌面和专用领域的多个版本
- 强调安全性和自主可控，广泛应用于政府、军事、金融等关键领域
- 提供类似 Windows 的图形界面，降低用户迁移成本

**应用现状**：
- 已在多个政府部门和国企实现了规模化部署
- 建立了较为完善的应用生态系统
- 国产化替代进程中的重要选择

### OpenEuler

OpenEuler 是华为公司发起并开源的 Linux 发行版，定位于服务器操作系统。

**主要特点**：
- 完全开源，采用开放社区治理模式
- 优化支持鲲鹏处理器等多种硬件架构
- 提供先进的云原生、虚拟化和容器技术支持
- 具有高可靠性、高性能和高安全性特性
- 支持多种场景，包括传统数据中心和云环境

**应用现状**：
- 已成为开源社区中活跃的项目之一
- 被多家企业和机构采用，特别是在云计算领域
- 持续增强对国产软硬件的支持和优化

**个人评价**：
国产操作系统在近年来取得了显著进步，从最初的"换皮"Linux 到如今具有自主创新点的系统。麒麟操作系统在安全性和稳定性方面表现出色，适合对安全要求高的场景；而 OpenEuler 则在开源社区建设和云原生支持方面走在前列。然而，这些系统在应用生态和用户体验上与国际主流操作系统相比仍有差距。未来发展关键在于建立完善的应用生态系统，提高软硬件兼容性，以及持续改进用户体验。

## xv6 源代码阅读问题

参考 xv6-book 章节：2.6, 4.1~4.5, 5.1~5.4。
参考 xv6-riscv 相关源代码⽂件：kernel ⽬录下：`entry.S`, `start.c`, `main.c`, `trap.c`, `trampoline.S`, `syscall.h`, `syscall.c`, `kernelvec.S`, `uart.c`, `console.c`

### a) 特权模式及启动转换过程 (boot)

**问题**：xv6-riscv 有⼏个特权模式，分别是什么？阅读 entry.S, start.c 以及 main.c 部分代码及 xv6-book 2.6 节，结合课上讲解的 xv6-riscv 启动流程，给出 xv6-riscv 启动阶段特权模式的转换过程（例如，在 xxx 函数内发⽣特权模式 X 到特权模式 Y 的转换）。

**回答**：

xv6-riscv 使用了 RISC-V 架构的 3 个特权模式中的 2 个：

1. **Machine Mode (M-mode)**：最高特权级别，具有完全的硬件访问权限
2. **Supervisor Mode (S-mode)**：中等特权级别，运行操作系统内核
3. *(User Mode (U-mode)：最低特权级别，运行用户程序，xv6 使用但不在启动过程中)*

**启动阶段特权模式转换过程**：

1. **机器上电后**：CPU 从 ROM 加载引导程序并以 **Machine Mode** 开始执行
2. **在 _entry 函数中**（entry.S）：配置初始堆栈，仍然在 **Machine Mode** 下执行
3. **在 start 函数中**（start.c）：
   - 设置 M-mode 下的中断和异常处理
   - 设置页表和其他必要的寄存器
   - 通过执行 `mret` 指令，**从 Machine Mode 切换到 Supervisor Mode**
   - 此时控制权转移到 main 函数
4. **在 main 函数中**（main.c）：在 **Supervisor Mode** 下执行系统初始化，包括内存管理、进程管理等组件的初始化

这种设计使得只有最基本的硬件初始化在最高特权级别（M-mode）完成，而大部分操作系统代码则在较低的特权级别（S-mode）运行，提高了系统的安全性和可靠性。

### b) 系统调用寄存器使用 (syscall)

**问题**：xv6-riscv 进⾏系统调⽤时，系统调⽤号、参数以及返回值分别通过哪些寄存器传递？

**回答**：

在 xv6-riscv 中，系统调用的相关信息通过以下寄存器传递：

1. **系统调用号**：通过寄存器 `a7` 传递
2. **系统调用参数**：通过寄存器 `a0` 到 `a5` 传递，最多支持 6 个参数
   - 第一个参数：`a0`
   - 第二个参数：`a1`
   - 依此类推
3. **系统调用返回值**：通过寄存器 `a0` 返回

这种寄存器分配方式遵循了 RISC-V 架构的调用约定，使得用户程序和内核之间的接口保持一致和高效。当用户程序触发系统调用（通过 `ecall` 指令）时，CPU 控制转移到内核，内核根据 `a7` 中的系统调用号来确定要执行的系统调用，处理完成后将结果放入 `a0` 寄存器并返回用户空间。

### c) 进程上下文切换寄存器 (trap)

**问题**：xv6-riscv 在进⾏进程上下⽂切换时，需要保存和恢复的寄存器有哪些？

**回答**：

xv6-riscv 在进程上下文切换时，需要保存和恢复以下寄存器：

1. **被调用者保存寄存器**（Callee-saved registers）：
   - `ra`：返回地址寄存器
   - `sp`：栈指针寄存器
   - `s0`/`fp`：帧指针寄存器
   - `s1-s11`：保存寄存器

xv6-riscv 中的上下文切换过程主要在 `swtch` 函数中完成，该函数保存当前上下文到一个结构体中，然后恢复下一个进程的上下文。这些寄存器的保存和恢复确保了进程可以在被中断后继续执行，就像从未被中断一样。

值得注意的是，xv6-riscv 中的上下文切换不保存通用寄存器（如 `a0-a7`、`t0-t6` 等），因为根据调用约定，这些寄存器的值在函数调用之间可能会改变，因此不需要在上下文切换时保存。

### d) Trap 处理相关寄存器 (trap)

**问题**：xv6-riscv 在处理 trap 时，使⽤了⼀系列控制寄存器，请阅读 xv6-book 4.1 节内容以及 trap.c 中的中断异常处理相关代码，简要说明以下寄存器的作⽤：stvec, sepc, scause, sstatus。

**回答**：

xv6-riscv 在处理 trap（中断、异常和系统调用）时，使用了以下 RISC-V 控制寄存器：

1. **stvec（Supervisor Trap Vector）**：
   - 用途：存储 trap 处理程序的地址
   - 作用：当发生 trap 时，硬件会自动将 PC 设置为 stvec 中存储的地址，从而开始执行 trap 处理程序
   - 在 xv6 中，通常指向 trampoline 页中的 uservec 或 kernelvec 函数

2. **sepc（Supervisor Exception Program Counter）**：
   - 用途：存储发生异常时的程序计数器（PC）值
   - 作用：保存发生 trap 前正在执行的指令地址，以便在 trap 处理完成后能够返回到正确的位置继续执行
   - 处理 trap 时通过 `sret` 指令恢复执行，此时 PC 被设置为 sepc 的值

3. **scause（Supervisor Cause Register）**：
   - 用途：指示 trap 的原因
   - 作用：包含一个代码，表示引起 trap 的具体事件（如页错误、系统调用、外部中断等）
   - xv6 的 trap 处理程序通过检查 scause 来确定如何处理不同类型的 trap

4. **sstatus（Supervisor Status Register）**：
   - 用途：控制和表示处理器的全局状态
   - 作用：包含多个重要标志位，如：
     - SIE 位：控制是否允许处理中断
     - SPP 位：指示 trap 发生前的特权模式（用户模式或监管模式）
     - 在 trap 处理过程中，通过修改 sstatus 中的相关位来禁用中断或更改特权模式

这些寄存器共同提供了 trap 处理所需的上下文信息和控制机制，使操作系统能够正确响应和处理各种中断和异常。

### e) 中断处理函数流程 (interrupt)

**问题**：阅读 uart.c 和 trap.c 中有关中断的代码以及 xv6-book 5.1～5.2 节，简要总结 devintr 和 uartintr 两个函数内部流程，及 devintr 内调⽤ uartintr 的判断条件。

**回答**：

**devintr 函数流程**：
1. 首先，检查 scause 寄存器的最高位（第63位）是否为 1，以确定是否为外部中断
2. 如果是外部中断，进一步检查 scause 的低位，确定具体的中断类型
3. 对于不同类型的中断，调用相应的处理函数：
   - 对于时钟中断：调用 `yield()` 函数进行进程调度
   - 对于 UART 中断：调用 `uartintr()` 函数处理串口中断
   - 对于其他设备中断：调用相应的处理函数
4. 处理完中断后，返回 1 表示成功处理了设备中断
5. 如果不是设备中断（scause 最高位为 0 或不是已知的中断类型），返回 0

**uartintr 函数流程**：
1. 循环检查 UART 控制寄存器，直到没有数据可读
2. 对于每个可读的字符：
   - 从 UART 数据寄存器读取字符
   - 如果 UART 接收缓冲区未满，将字符放入缓冲区
   - 如果字符是特殊控制字符（如 Ctrl+P），执行特殊操作
3. 根据需要唤醒等待 UART 输入的进程

**devintr 内调用 uartintr 的判断条件**：
devintr 在以下条件下会调用 uartintr：
- scause 寄存器的最高位（第63位）为 1，表示这是一个中断而非异常
- scause 的低位值为 9，表示这是一个外部设备中断
- 通过调用 `plic_claim()` 获取到的中断源是 UART_IRQ，表示这是来自 UART 设备的中断

这种分层设计使得 xv6 能够统一处理各种设备中断，同时为不同设备提供专门的处理函数。
