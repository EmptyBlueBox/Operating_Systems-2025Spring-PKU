# 2019年秋季学期操作系统期中考试题目总结

## 一、 运行环境和运行机制 (30 分)

1.  (4 分) CPU 状态是软件实现的还是硬件实现的? 为什么这么实现?

    CPU状态是硬件实现的。因为CPU状态需要快速响应硬件事件、保证运行时的高效性，同时需要防止软件篡改特权状态，确保系统安全性。硬件实现使得状态切换可以由物理机制保证，不依赖于软件可靠性。

2.  (4 分) 举例说明中断/异常的区别。

    中断是来自CPU外部的事件引起的，如时钟中断、I/O中断、键盘中断等，是异步发生的；而异常是CPU执行指令时内部产生的事件，如除零错误、页错误、非法指令等，是同步发生的。中断通常可屏蔽，而异常一般不可屏蔽需立即处理。

3.  (10 分) 以时间中断为例, 描述处理中断/异常的过程 (包括硬件实现的部分和操作系统实现的部分)。

    时钟中断处理过程：
    - 硬件部分：
    1. 时钟芯片计数器达到预设值，向CPU发送中断信号
    2. CPU完成当前指令执行后检测到中断信号
    3. CPU保存当前程序状态 (PC、寄存器值等) 到内核栈
    4. CPU切换到内核态，将控制权转移到中断向量表中对应时钟中断的处理程序入口

    - 操作系统部分：
    1. 保存进一步的上下文信息
    2. 执行时钟中断服务例程：更新系统时间，检查进程时间片是否用完
    3. 若时间片用完，触发进程调度，选择下一个要运行的进程
    4. 恢复新进程的上下文
    5. 从中断处理程序返回，CPU根据恢复的状态继续执行

4.  (4 分) 系统调用有什么作用? 它和函数调用有什么区别?

    系统调用作用：为用户程序提供访问操作系统服务的接口，使应用程序能够请求操作系统执行需要特权级别的操作，如I/O、进程创建等。

    与函数调用区别：系统调用涉及从用户态到内核态的特权级切换，而普通函数调用在同一特权级内进行；系统调用通过特殊指令 (如INT) 实现，而函数调用通过CALL指令实现；系统调用需要参数传递机制 (如寄存器或内存) 来跨越特权边界，而函数调用直接通过栈传参。

5.  (8 分) 操作系统是如何实现系统调用的?

    1. 用户程序将系统调用号和参数存入寄存器或栈中
    2. 执行特权指令 (如x86的INT 0x80或SYSCALL) 触发从用户态到内核态的切换
    3. CPU保存用户态上下文到内核栈中 (之后可能进一步保存在 PCB 中的数据结构)，切换到内核态
    4. 硬件跳转到系统调用处理例程入口
    5. 内核根据系统调用号查找系统调用表，找到对应的内核函数
    6. 内核验证参数，执行相应的内核服务
    7. 执行完毕，将结果存放在约定位置 (通常是特定寄存器) 
    8. 通过特权指令 (如IRET或SYSRET) 恢复用户态上下文，返回用户程序 (此时可能触发程序调度)

## 二、 进程线程模型 (25 分)

1.  (8 分) PCB 的作用是什么? PCB 里保存了哪些内容? PCB 和进程的调度/切换有什么关系? PCB 是如何保存进程地址空间的?

    PCB (进程控制块) 作用：是操作系统管理进程的核心数据结构，记录进程的所有信息，使操作系统能够对进程进行管理和控制。

    PCB内容：
    - 进程标识信息 (PID、用户ID) 
    - CPU状态信息 (寄存器值、程序计数器、PSW) 
    - 进程调度信息 (进程状态、优先级、调度相关的统计信息) 
    - 内存管理信息 (页表或段表指针，内存限制) 
    - I/O状态信息 (打开文件列表，I/O请求) 
    - 会计信息 (CPU时间、时钟时间) 

    PCB与进程调度/切换关系：进程调度器通过PCB中的调度信息选择下一个运行的进程；进程切换时，通过PCB保存当前进程状态并恢复新进程的状态，是上下文切换的核心数据结构。

    PCB保存进程地址空间：PCB不直接保存进程地址空间内容，而是保存指向内存管理数据结构 (如页表、段表) 的指针，这些数据结构描述了进程的虚拟地址到物理地址的映射关系。

2.  (4 分) 进程是如何创建的?

    1. 通过系统调用 (如fork、exec) 请求创建新进程
    2. 操作系统分配新的PID，创建新的PCB结构
    3. 分配必要的资源 (内存空间、初始化页表) 
    4. 复制或设置初始化数据 (若是fork则复制父进程数据，若是exec则加载新程序) 
    5. 初始化PCB中的各项信息 (状态、优先级、程序计数器等) 
    6. 将新进程加入就绪队列等待调度
    7. 返回到父进程，同时新进程等待被调度执行

3.  (9 分) 画出五状态进程模型 (包括状态名称和转移条件)。

    五状态进程模型：
    - 新建状态：进程被创建但尚未加入就绪队列
    - 转移到就绪：系统完成初始化并有足够资源
    - 就绪状态：进程已准备好运行，等待CPU分配
    - 转移到运行：调度器选择该进程执行
    - 运行状态：进程正在CPU上执行
    - 转移到就绪：时间片用完或更高优先级进程抢占
    - 转移到阻塞：进程等待某事件 (如I/O操作) 
    - 转移到终止：进程执行完毕或出现错误
    - 阻塞状态：进程等待某事件发生，暂不能执行
    - 转移到就绪：等待的事件发生 (如I/O完成) 
    - 终止状态：进程执行结束，释放资源前的过渡状态
    - 完全终止：系统回收所有资源

4.  (4 分) 用户线程和核心线程有什么区别?

    用户线程与核心线程的区别：
    - 实现层次：用户线程由用户空间的线程库实现，核心线程由操作系统内核实现
    - 系统感知：操作系统不感知用户线程存在，而直接管理核心线程
    - 调度方式：用户线程由线程库在用户空间调度，核心线程由内核调度器调度
    - 系统调用：用户线程的切换不需要系统调用，而核心线程切换需要陷入内核
    - 阻塞影响：一个用户线程阻塞会导致其所属进程的所有线程都阻塞，而核心线程可以独立阻塞
    - 并行能力：用户线程不能利用多处理器并行，核心线程可以在多处理器上并行执行

## 三、 进程线程调度 (20 分)

1.  (10 分) (作业题) 对某系统进行监测后发现, 在阻塞 I/O 之前, 平均每个进程运行时间为 T。一次进程切换需要的时间为 S, 这里 S 实际上就是开销。对于采用时间片长度为 Q 的轮转调度, 请给出以下各种情况的 CPU 利用率的计算公式:

    (a) Q = ∞
    CPU利用率 = T/(T+S)
    当时间片无限大时，进程会一直运行到阻塞，因此只有在阻塞时才发生上下文切换。

    (b) Q > T
    CPU利用率 = T/(T+S)
    当时间片大于平均运行时间时，进程在用完时间片前就会因I/O请求而阻塞，结果同(a)。

    (c) S < Q < T
    CPU利用率 = Q/(Q+S)
    当时间片小于平均运行时间但大于切换开销时，进程会因为时间片用完而被切换，平均每Q时间就发生一次切换。

    (d) Q = S
    CPU利用率 = S/(S+S) = 1/2
    当时间片等于切换开销时，系统有一半时间用于有效计算，一半时间用于切换。

    (e) Q 趋近于 0
    CPU利用率 → 0
    当时间片趋近于0时，系统几乎所有时间都花在进程切换上，几乎没有时间执行有效计算。

2.  (10 分) 请基于多级反馈调度算法设计一种调度算法, 并说明你设计的算法是如何使 I/O 密集型的进程优先调度的? 是如何避免"饥饿"发生的?

    基于多级反馈队列的优化调度算法设计：

    1. 队列设置：设置多个优先级队列 (Q0、Q1、...、Qn) ，每个队列的时间片大小从高到低依次增加 (如Q0为20ms，Q1为40ms...) 

    2. 新进程处理：新进程首先进入最高优先级队列Q0

    3. 时间片用完处理：若进程在当前队列用完时间片，降低其优先级 (进入下一级队列) 

    4. I/O处理：当进程因I/O阻塞而释放CPU时，回到原优先级队列的头部，而不是降级

    5. 队列调度：优先调度高优先级队列中的进程，只有高优先级队列为空时才调度低优先级队列

    6. 优先级提升：定期 (如每隔一段时间T) 将所有进程重新放入最高优先级队列

    7. 资源占用惩罚：检测CPU密集型进程，如连续多次用完时间片的进程，可额外降低其优先级

    I/O密集型进程优先调度的实现：
    I/O密集型进程通常在发出I/O请求前只运行很短时间就阻塞，不会用完时间片，因此当I/O完成后回到原队列头部，获得较高优先级。而CPU密集型进程会频繁用完时间片被降级，从而使I/O密集型进程获得优先调度。

    避免饥饿的实现：
    通过定期的优先级提升 (老化机制) ，确保长期处于低优先级队列的进程也能定期获得CPU时间，防止饥饿现象。同时，队列的时间片增长策略也确保低优先级队列中的进程获得更长执行时间，提高其完成工作的机会。

## 四、 同步互斥机制 (25 分)

1.  (5 分) Hoare 管程和 Mesa 管程的区别是什么?

    Hoare管程和Mesa管程的区别：
    - 信号处理机制：Hoare管程中，当一个进程发出 signal 信号时，立即将CPU控制权交给等待该信号的进程；Mesa管程中， notify 只是将等待进程唤醒并放入就绪队列，但不立即让出CPU。
    - 执行顺序：Hoare管程中，被唤醒的进程立即执行，而唤醒它的进程等待；Mesa管程中，发出 notify 的进程继续执行，被唤醒的进程只是变为就绪状态，等待调度。
    - 效率与实现复杂度：Mesa管程实现更简单，开销更小，但可能导致被唤醒进程等待更长时间；Hoare管程实现复杂，但对于被唤醒进程响应更及时。
    - 条件变量语义：Mesa管程需要在while循环中重新检查条件 (因为被唤醒时条件可能已改变) ，而Hoare管程可以直接假设条件满足。

2.  (10 分) 用信号量、PV 操作模拟美容师问题, 实现美容院进程与顾客进程:
    美容店有 3 位美容师、3 把美容椅和 10 把顾客等候区椅子, 要求: 如果没有顾客, 美容师便休息或聊天。一个顾客到来时, 如果有美容师空闲, 顾客会选择一位美容师开始美容; 如果没有理发师空闲, 等候区有空椅子可坐, 就坐下来等待; 否则就离开。

    **答**: 
    这是典型的"睡眠理发师"问题的一个变体，拥有多个理发师（"服务员"）和有限的等候座位（"缓冲区"）。我们可以使用信号量来协调顾客和美容师进程。

    #### 1. 关系分析
    *   **角色**: 顾客 (Customer), 美容师 (Beautician)
    *   **资源**: 美容椅 (3个，由美容师数量体现), 等候区椅子 (10个)
    *   **互斥关系**: 对等候区椅子数量的修改需要互斥，以防多个顾客同时试图坐下或计票错误。
    *   **同步关系**:
        1.  如果没有顾客，美容师必须等待（睡眠）。
        2.  如果美容师都在忙，顾客必须在有空椅子的情况下等待。
        3.  如果等候区也满了，顾客必须离开。
        4.  顾客的到来会唤醒一个正在等待的美容师。

    #### 2. 信号量和变量设置
    我们将问题建模为生产者（顾客）-消费者（美容师）模型。
    *   `beauticians (semaphore)`: 代表**空闲美容师**的数量。顾客在需要服务时会请求（P操作）一个美容师。初始值为3。
    *   `customers (semaphore)`: 代表在**等候区等待**的顾客数量。美容师在寻找顾客时会检查（P操作）这个信号量。初始值为0。
    *   `mutex (semaphore)`: 二元信号量，用于保护对共享变量 `waiting_chairs_count` 的访问，确保原子性操作。初始值为1。
    *   `waiting_chairs_count (int)`: 记录当前已被占用的等候区椅子数量。初始值为0。
    *   `MAX_WAITING_CHAIRS (const int)`: 等候区椅子的总数，为10。

    #### 3. 伪代码实现

    ```c++
    // --- 常量和共享变量 ---
    const int MAX_WAITING_CHAIRS = 10;
    int waiting_chairs_count = 0;

    // --- 信号量 ---
    // beauticians: 初始时有3个空闲美容师
    semaphore beauticians = 3;
    // customers: 初始时没有顾客在等待
    semaphore customers = 0;
    // mutex: 用于保护 waiting_chairs_count 的互斥锁
    semaphore mutex = 1;


    // --- 顾客进程 ---
    void CustomerProcess() {
        /*
         * 模拟一个顾客的生命周期。
         * 顾客到达，检查是否有等候区的空椅子。
         * 如果有，则坐下等待，并最终获得服务。
         * 如果没有，则直接离开。
         */
        P(mutex); // 请求进入临界区，检查和修改等待椅子数
        if (waiting_chairs_count < MAX_WAITING_CHAIRS) {
            // 等候区有空位
            waiting_chairs_count++; // 占据一个等候区座位
            V(mutex);     // 释放临界区锁

            V(customers); // 通知美容师, 我来了

            P(beauticians); // 等待美容师准备好 (即美容师被叫醒给自己服务)
            
            // --- 美容服务正在进行 ---
            // get_service();
            // --- 服务结束，顾客离开 ---

        } else {
            // 等候区已满，顾客直接离开
            V(mutex); // 必须在离开前释放锁
            // leave_shop();
        }
    }


    // --- 美容师进程 ---
    void BeauticianProcess() {
        /*
         * 模拟一个美容师的无限工作循环。
         * 美容师等待顾客的到来。
         * 当有顾客时，为其服务。
         * 服务完成后，美容师变为空闲，等待下一位顾客。
         */
        while (true) {
            P(customers); // P(customers): 等待一位顾客的到来。如果没有顾客，美容师在此睡眠或聊天。

            P(mutex); // 请求进入临界区
            // 一位顾客从等候区移至美容椅，因此等候区空出一个座位
            waiting_chairs_count--;
            V(mutex); // 释放临界区锁
            
            V(beauticians); // 美容师被叫醒, 可以开始为顾客服务了

            // --- 正在为顾客服务 ---
            // provide_service();

        }
    }
    ```

    #### 4. 工作原理解释

    这个解决方案将美容院的运作视为一个生产者-消费者系统。

    *   **美容师 (`beauticians`) 信号量**: 它的计数值代表了当前有多少美容师是空闲的。顾客进程在需要服务前，必须执行 `P(beauticians)` 来获取一个空闲美容师。如果计数值为0（所有美容师都在忙），顾客进程就会在此等待。当一个美容师完成服务后，会执行 `V(beauticians)`，表示自己又空闲了，从而可以唤醒一个正在等待的顾客。

    *   **顾客 (`customers`) 信号量**: 它的计数值代表了有多少顾客正在等候区等待服务。美容师进程通过执行 `P(customers)` 来获取一位顾客。如果计数值为0（没有等待的顾客），美容师进程就会在此睡眠，直到有新顾客到来。

    *   **互斥 (`mutex` 和 `waiting_chairs_count`)**: 由于多个顾客可能同时到达，对等候区座位数 `waiting_chairs_count` 的检查和修改必须是原子操作。`mutex` 信号量确保了在任何时刻只有一个顾客进程可以访问这个计数器，从而避免了多个顾客以为有同一个空座位而导致计数错误。当顾客决定等待时，他先锁住 `mutex`，增加计数，然后释放 `mutex`。这样就准确地记录了等候区的占用情况。当顾客被美容师接待时，美容师同样会通过 `mutex` 来安全地减少这个计数。

3.  (10 分) 用管程模拟顾客进出超市问题:
    某物美超市有 100 辆购物推车, 顾客进入时要刷会员卡领取一辆推车, 如果超市没有空闲推车, 则顾客在超市门口等待。顾客买完东西结账离开时需刷卡还回推车。

    ```c++
    // 超市管程
    class Supermarket {
        /* 
         * Variables:
         * carts (int): 当前可用的购物车数量
         * total_carts (int): 购物车总数，固定为100
         */
        private int carts = 100;
        private const int total_carts = 100;
        
        // 顾客等待购物车的条件变量
        private condition cart_available;
        
        // 顾客获取购物车的方法
        public void get_cart() {
            /* 
             * Input: None
             * Output: None
             * 顾客尝试获取购物车，如果没有可用购物车则等待
             */
            while (carts <= 0) {
                // 没有可用购物车，等待
                cart_available.wait();
            }
            // 获取购物车
            carts--;
        }
        
        // 顾客归还购物车的方法
        public void return_cart() {
            /* 
             * Input: None
             * Output: None
             * 顾客归还购物车，唤醒一个等待购物车的顾客
             */
            carts++;
            cart_available.signal();
        }
    }

    // 顾客进程
    void customer() {
        /* 
         * 顾客进程模拟
         */
        // 获取购物车进入超市
        Supermarket.get_cart();
        
        // 购物...
        
        // 结账离开，归还购物车
        Supermarket.return_cart();
    }
    ```
