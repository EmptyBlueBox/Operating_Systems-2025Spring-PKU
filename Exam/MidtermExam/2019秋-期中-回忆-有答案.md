## 一、 运行环境和运行机制 (30 分)

1.  (4 分) CPU 状态是软件实现的还是硬件实现的? 为什么这么实现?

    CPU状态是硬件实现的。因为CPU状态需要快速响应硬件事件、保证运行时的高效性，同时需要防止软件篡改特权状态，确保系统安全性。硬件实现使得状态切换可以由物理机制保证，不依赖于软件可靠性。

2.  (4 分) 举例说明中断/异常的区别。

    中断是来自CPU外部的事件引起的，如时钟中断、I/O中断、键盘中断等，是异步发生的；而异常是CPU执行指令时内部产生的事件，如除零错误、页错误、非法指令等，是同步发生的。中断通常可屏蔽，而异常一般不可屏蔽需立即处理。

3.  (10 分) 以时间中断为例, 描述处理中断/异常的过程 (包括硬件实现的部分和操作系统实现的部分)。

    时钟中断处理过程：
    - 硬件部分：
    1. 时钟芯片计数器达到预设值，向CPU发送中断信号
    2. CPU完成当前指令执行后检测到中断信号
    3. CPU保存当前程序状态 (PC、寄存器值等) 到内核栈
    4. CPU切换到内核态，将控制权转移到中断向量表中对应时钟中断的处理程序入口

    - 操作系统部分：
    1. 保存进一步的上下文信息
    2. 执行时钟中断服务例程：更新系统时间，检查进程时间片是否用完
    3. 若时间片用完，触发进程调度，选择下一个要运行的进程
    4. 恢复新进程的上下文
    5. 从中断处理程序返回，CPU根据恢复的状态继续执行

4.  (4 分) 系统调用有什么作用? 它和函数调用有什么区别?

    系统调用作用：为用户程序提供访问操作系统服务的接口，使应用程序能够请求操作系统执行需要特权级别的操作，如I/O、进程创建等。

    与函数调用区别：系统调用涉及从用户态到内核态的特权级切换，而普通函数调用在同一特权级内进行；系统调用通过特殊指令 (如INT) 实现，而函数调用通过CALL指令实现；系统调用需要参数传递机制 (如寄存器或内存) 来跨越特权边界，而函数调用直接通过栈传参。

5.  (8 分) 操作系统是如何实现系统调用的?

    1. 用户程序将系统调用号和参数存入寄存器或栈中
    2. 执行特权指令 (如x86的INT 0x80或SYSCALL) 触发从用户态到内核态的切换
    3. CPU保存用户态上下文到内核栈中 (之后可能进一步保存在 PCB 中的数据结构)，切换到内核态
    4. 硬件跳转到系统调用处理例程入口
    5. 内核根据系统调用号查找系统调用表，找到对应的内核函数
    6. 内核验证参数，执行相应的内核服务
    7. 执行完毕，将结果存放在约定位置 (通常是特定寄存器) 
    8. 通过特权指令 (如IRET或SYSRET) 恢复用户态上下文，返回用户程序 (此时可能触发程序调度)

## 二、 进程线程模型 (25 分)

1.  (8 分) PCB 的作用是什么? PCB 里保存了哪些内容? PCB 和进程的调度/切换有什么关系? PCB 是如何保存进程地址空间的?

    PCB (进程控制块) 作用：是操作系统管理进程的核心数据结构，记录进程的所有信息，使操作系统能够对进程进行管理和控制。

    PCB内容：
    - 进程标识信息 (PID、用户ID) 
    - CPU状态信息 (寄存器值、程序计数器、PSW) 
    - 进程调度信息 (进程状态、优先级、调度相关的统计信息) 
    - 内存管理信息 (页表或段表指针，内存限制) 
    - I/O状态信息 (打开文件列表，I/O请求) 
    - 会计信息 (CPU时间、时钟时间) 

    PCB与进程调度/切换关系：进程调度器通过PCB中的调度信息选择下一个运行的进程；进程切换时，通过PCB保存当前进程状态并恢复新进程的状态，是上下文切换的核心数据结构。

    PCB保存进程地址空间：PCB不直接保存进程地址空间内容，而是保存指向内存管理数据结构 (如页表、段表) 的指针，这些数据结构描述了进程的虚拟地址到物理地址的映射关系。

2.  (4 分) 进程是如何创建的?

    1. 通过系统调用 (如fork、exec) 请求创建新进程
    2. 操作系统分配新的PID，创建新的PCB结构
    3. 分配必要的资源 (内存空间、初始化页表) 
    4. 复制或设置初始化数据 (若是fork则复制父进程数据，若是exec则加载新程序) 
    5. 初始化PCB中的各项信息 (状态、优先级、程序计数器等) 
    6. 将新进程加入就绪队列等待调度
    7. 返回到父进程，同时新进程等待被调度执行

3.  (9 分) 画出五状态进程模型 (包括状态名称和转移条件)。

    五状态进程模型：
    - 新建状态：进程被创建但尚未加入就绪队列
    - 转移到就绪：系统完成初始化并有足够资源
    - 就绪状态：进程已准备好运行，等待CPU分配
    - 转移到运行：调度器选择该进程执行
    - 运行状态：进程正在CPU上执行
    - 转移到就绪：时间片用完或更高优先级进程抢占
    - 转移到阻塞：进程等待某事件 (如I/O操作) 
    - 转移到终止：进程执行完毕或出现错误
    - 阻塞状态：进程等待某事件发生，暂不能执行
    - 转移到就绪：等待的事件发生 (如I/O完成) 
    - 终止状态：进程执行结束，释放资源前的过渡状态
    - 完全终止：系统回收所有资源

4.  (4 分) 用户线程和核心线程有什么区别?

    用户线程与核心线程的区别：
    - 实现层次：用户线程由用户空间的线程库实现，核心线程由操作系统内核实现
    - 系统感知：操作系统不感知用户线程存在，而直接管理核心线程
    - 调度方式：用户线程由线程库在用户空间调度，核心线程由内核调度器调度
    - 系统调用：用户线程的切换不需要系统调用，而核心线程切换需要陷入内核
    - 阻塞影响：一个用户线程阻塞会导致其所属进程的所有线程都阻塞，而核心线程可以独立阻塞
    - 并行能力：用户线程不能利用多处理器并行，核心线程可以在多处理器上并行执行

## 三、 进程线程调度 (20 分)

1.  (10 分) (作业题) 对某系统进行监测后发现, 在阻塞 I/O 之前, 平均每个进程运行时间为 T。一次进程切换需要的时间为 S, 这里 S 实际上就是开销。对于采用时间片长度为 Q 的轮转调度, 请给出以下各种情况的 CPU 利用率的计算公式:

    (a) Q = ∞
    CPU利用率 = T/(T+S)
    当时间片无限大时，进程会一直运行到阻塞，因此只有在阻塞时才发生上下文切换。

    (b) Q > T
    CPU利用率 = T/(T+S)
    当时间片大于平均运行时间时，进程在用完时间片前就会因I/O请求而阻塞，结果同(a)。

    (c) S < Q < T
    CPU利用率 = Q/(Q+S)
    当时间片小于平均运行时间但大于切换开销时，进程会因为时间片用完而被切换，平均每Q时间就发生一次切换。

    (d) Q = S
    CPU利用率 = S/(S+S) = 1/2
    当时间片等于切换开销时，系统有一半时间用于有效计算，一半时间用于切换。

    (e) Q 趋近于 0
    CPU利用率 → 0
    当时间片趋近于0时，系统几乎所有时间都花在进程切换上，几乎没有时间执行有效计算。

2.  (10 分) 请基于多级反馈调度算法设计一种调度算法, 并说明你设计的算法是如何使 I/O 密集型的进程优先调度的? 是如何避免"饥饿"发生的?

    基于多级反馈队列的优化调度算法设计：

    1. 队列设置：设置多个优先级队列 (Q0、Q1、...、Qn) ，每个队列的时间片大小从高到低依次增加 (如Q0为20ms，Q1为40ms...) 

    2. 新进程处理：新进程首先进入最高优先级队列Q0

    3. 时间片用完处理：若进程在当前队列用完时间片，降低其优先级 (进入下一级队列) 

    4. I/O处理：当进程因I/O阻塞而释放CPU时，回到原优先级队列的头部，而不是降级

    5. 队列调度：优先调度高优先级队列中的进程，只有高优先级队列为空时才调度低优先级队列

    6. 优先级提升：定期 (如每隔一段时间T) 将所有进程重新放入最高优先级队列

    7. 资源占用惩罚：检测CPU密集型进程，如连续多次用完时间片的进程，可额外降低其优先级

    I/O密集型进程优先调度的实现：
    I/O密集型进程通常在发出I/O请求前只运行很短时间就阻塞，不会用完时间片，因此当I/O完成后回到原队列头部，获得较高优先级。而CPU密集型进程会频繁用完时间片被降级，从而使I/O密集型进程获得优先调度。

    避免饥饿的实现：
    通过定期的优先级提升 (老化机制) ，确保长期处于低优先级队列的进程也能定期获得CPU时间，防止饥饿现象。同时，队列的时间片增长策略也确保低优先级队列中的进程获得更长执行时间，提高其完成工作的机会。

## 四、 同步互斥机制 (25 分)

1.  (5 分) Hoare 管程和 Mesa 管程的区别是什么?

    Hoare管程和Mesa管程的区别：
    - 信号处理机制：Hoare管程中，当一个进程发出signal信号时，立即将CPU控制权交给等待该信号的进程；Mesa管程中，signal只是将等待进程唤醒并放入就绪队列，但不立即让出CPU。
    - 执行顺序：Hoare管程中，被唤醒的进程立即执行，而唤醒它的进程等待；Mesa管程中，发出signal的进程继续执行，被唤醒的进程只是变为就绪状态，等待调度。
    - 效率与实现复杂度：Mesa管程实现更简单，开销更小，但可能导致被唤醒进程等待更长时间；Hoare管程实现复杂，但对于被唤醒进程响应更及时。
    - 条件变量语义：Mesa管程需要在while循环中重新检查条件 (因为被唤醒时条件可能已改变) ，而Hoare管程可以直接假设条件满足。

2.  (10 分) 用信号量、PV 操作模拟美容师问题, 实现美容院进程与顾客进程:
    美容店有 3 位美容师、3 把美容椅和 10 把顾客等候区椅子, 要求: 如果没有顾客, 美容师便休息或聊天。一个顾客到来时, 如果有美容师空闲, 顾客会选择一位美容师开始美容; 如果没有理发师空闲, 等候区有空椅子可坐, 就坐下来等待; 否则就离开。

    ```c
    // 定义信号量
    semaphore customers = 0;     // 等待美容的顾客数
    semaphore beauticians = 3;   // 可用的美容师数量
    semaphore chairs = 10;       // 等候区可用椅子数
    semaphore mutex = 1;         // 互斥访问共享变量的信号量

    // 顾客进程
    void customer() {
        /* 
        * 顾客进程的执行逻辑
        * 尝试进入美容店并获取服务
        */
        if (P(chairs, 0)) {      // 非阻塞尝试获取等候椅
            P(chairs);           // 获取等候椅
            P(mutex);
            // 增加等待顾客计数等操作
            V(mutex);
            V(customers);        // 通知有顾客等待
            P(beauticians);      // 等待美容师可用
            V(chairs);           // 释放等候椅
            
            // 接受美容服务
            
            // 美容完成后离开
        } else {
            // 没有可用椅子，顾客离开
        }
    }

    // 美容师进程
    void beautician() {
        /* 
        * 美容师进程的执行逻辑
        * 服务顾客或空闲时休息
        */
        while (true) {
            P(customers);        // 等待顾客到来
            V(beauticians);      // 表示美容师开始服务，释放资源让顾客获得
            
            // 提供美容服务
            
            // 服务完成
        }
    }
    ```
3.  (10 分) 用管程模拟顾客进出超市问题:
    某物美超市有 100 辆购物推车, 顾客进入时要刷会员卡领取一辆推车, 如果超市没有空闲推车, 则顾客在超市门口等待。顾客买完东西结账离开时需刷卡还回推车。

    ```c
    // 超市管程
    monitor Supermarket {
        /* 
         * Variables:
         * carts (int): 当前可用的购物车数量
         * total_carts (int): 购物车总数，固定为100
         */
        private int carts = 100;
        private const int total_carts = 100;
        
        // 顾客等待购物车的条件变量
        private condition cart_available;
        
        // 顾客获取购物车的方法
        public void get_cart() {
            /* 
             * Input: None
             * Output: None
             * 顾客尝试获取购物车，如果没有可用购物车则等待
             */
            if (carts <= 0) {
                // 没有可用购物车，等待
                wait(cart_available);
            }
            // 获取购物车
            carts--;
        }
        
        // 顾客归还购物车的方法
        public void return_cart() {
            /* 
             * Input: None
             * Output: None
             * 顾客归还购物车，唤醒一个等待购物车的顾客
             */
            carts++;
            if (carts > 0) {
                // 有购物车可用，唤醒一个等待的顾客
                signal(cart_available);
            }
        }
    }

    // 顾客进程
    void customer() {
        /* 
         * 顾客进程模拟
         */
        // 获取购物车进入超市
        Supermarket.get_cart();
        
        // 购物...
        
        // 结账离开，归还购物车
        Supermarket.return_cart();
    }
    ```
