# 2015年秋季学期操作系统期末考试题目总结

## 一、简答题 (共20分, 每题5分)

1.  关于CPU特权等级的问题。

    CPU特权等级是一种硬件保护机制，它将处理器操作模式至少分为**内核态**和**用户态**。
    
    *   **内核态 (高特权):** 运行操作系统内核，可以执行所有指令，访问所有硬件资源。
    *   **用户态 (低特权):** 运行应用程序，指令和资源访问受限。
    
    这种分离设计通过**防止用户程序直接执行危险指令**来保护系统稳定。当用户程序需要进行I/O等特权操作时，必须通过**系统调用 (System Call)** 的方式请求内核服务，此时CPU会从用户态切换到内核态，完成操作后再切换回来。

2.  哪些调度方式可能导致饥饿？哪些可能导致优先级反转？

    *   **导致饥饿 (Starvation):**
        *   **严格优先级调度:** 低优先级进程可能永远被高优先级进程抢占。
        *   **最短作业优先 (SJF):** 长作业可能永远被源源不断的新短作业插队。

    *   **导致优先级反转 (Priority Inversion):**
        *   抢占式优先级调度 + 共享资源（如锁）。一个高优先级任务(H)因等待低优先级任务(L)持有的锁而被阻塞。此时，一个中优先级任务(M)抢占了L，导致L迟迟无法释放锁，从而间接阻塞了H。

3.  写时拷贝（Copy-on-Write）与内存映射文件（Memory-Mapped Files）的相似之处。

    两者核心的相似之处在于都应用了**延迟处理 (Lazy Evaluation)** 的思想，并且都依赖**缺页异常 (Page Fault)** 作为核心触发机制。都在虚拟内存中先建立一个"承诺"的映射，而不立即执行昂贵的数据操作（物理复制或文件读取）。

    *   **内存映射文件 (MMF):** 当访问一个未加载的页面时，触发缺页异常，**从磁盘按需调页**。
    *   **写时拷贝 (COW):** 当对一个共享的只读页面进行写入时，触发保护性缺页异常，**按需复制该页**使其私有化。

    两者都体现了虚拟内存的精髓：以页为单位，通过操纵页表实现高效的资源管理。

4.  以打印机输出为例，说明I/O软件（分层）的设计思想。

    I/O软件分层是将复杂的I/O流程分解为独立的层次，每层向上提供服务并隐藏下层细节。以打印为例：

    ```mermaid
    graph TD
        A["应用 (Word)"] --> B["设备无关层 (OS)"];
        B --> C["设备驱动层 (HP驱动)"];
        C --> D["硬件 (打印机)"];
    ```

    1.  **应用层:** 发起打印请求，不关心打印机型号。
    2.  **设备无关的I/O层:** 提供统一接口，并处理通用任务，如打印作业的缓冲和假脱机(Spooling)。
    3.  **设备驱动层:** 将上层的通用请求，翻译成特定打印机能懂的硬件指令（如PCL）。
    4.  **硬件层:** 实际执行指令的物理设备。

    **设计思想的好处:**
    *   **抽象与模块化:** 更换硬件只需更换驱动，上层软件不变。
    *   **统一性:** 不同应用可以使用同样的方式操作不同设备。

## 二、选做题 (二选一, 共10分)

1.  **分析以下轮序代码，指出其问题并提供解决方案。**

    ```assembly
    LOOP: TEST PORT-4
        BEQ READY
        BRANCH LOOP
    READY:
    ```

    **问题分析:**
    上述代码采用了 **"忙等待" (Busy-Waiting)** 或 **轮询 (Polling)** 的方式来检查I/O设备的状态。CPU会陷入一个循环 (`LOOP`)，不断地消耗时钟周期去读取设备端口 `PORT-4` 的状态，直到设备就绪。

    **主要问题:**
    *   **CPU效率低下:** 在等待设备期间，CPU被完全占用，无法执行其他任何有用的计算任务或调度其他进程。这在多任务操作系统中是极大的资源浪费。

    **解决方案:**
    改用 **中断驱动I/O (Interrupt-driven I/O)**。

    **改进流程:**
    1.  **发起请求:** CPU向设备发起一个I/O请求。
    2.  **阻塞/调度:** CPU不等待，而是将当前进程置于等待状态，并调度另一个就绪进程来执行。
    3.  **设备通知:** 当I/O设备完成操作时，它会向CPU发送一个 **中断信号**。
    4.  **中断处理:** CPU接收到中断后，暂停当前任务，跳转到该设备的 **中断服务程序 (ISR)**。
    5.  **处理数据:** ISR负责处理I/O，然后清除中断信号。
    6.  **恢复执行:** ISR执行完毕后，原先等待I/O的进程被唤醒，CPU恢复执行被中断的任务。

    **优点:**
    *   **解放CPU:** CPU无需空等，系统整体效率和吞吐量大大提高。
    *   **并发性:** 实现了CPU与I/O设备的真正并行工作。

2.  简述远程过程调用（RPC）是如何及为何要生成存根（stub）。**实验班问题，不考。**

## 三、存储管理 (共30分)

1. 简述在自选的内存组织方式下，系统解析一个内存地址时的软件和硬件行为。

   以现代操作系统中最核心的 **分页式虚拟存储 (Paging Virtual Memory)** 为例，解析一个内存地址（逻辑地址）涉及硬件和软件的协同工作。

   **1. 硬件行为 (MMU + TLB)**

   当CPU执行一条指令需要访问内存时，它发出的是一个 **逻辑地址 (Virtual Address)**。接下来的处理由CPU内的 **内存管理单元 (MMU)** 主导：

   *   **a. 查询快表 (TLB):** MMU首先从逻辑地址中提取出 **页号 (VPN)**，然后去查询 **TLB (Translation Lookaside Buffer)**。TLB是一个页表项的高速缓存。
       *   **TLB 命中 (Hit):** 如果在TLB中找到了对应的页号，MMU会立即获得其映射的 **物理页框号 (PFN)**。这是最快的情况。
       *   **TLB 未命中 (Miss):** 如果TLB中没有该页号的缓存，MMU就需要执行下一步。

   *   **b. 遍历页表 (Page Table Walk):**
       *   MMU会根据 **页表基址寄存器 (如CR3)** 指向的内存地址，在物理内存中查找 **页表 (Page Table)**。
       *   MMU使用页号作为索引，在页表中找到对应的 **页表项 (PTE)**。在多级页表结构中，这可能需要多次访问内存。
       *   **PTE有效 (Present Bit = 1):** 如果PTE表明该页在物理内存中，MMU会取出物理页框号，并 **将这个映射关系缓存到TLB中**，以备后续快速查找。
       *   **PTE无效 (Present Bit = 0 或权限不足):** 如果PTE表明该页不在内存，或当前操作违反了权限（如对只读页进行写操作），硬件无法自行处理，它会触发一个 **缺页异常 (Page Fault)**，并将控制权交给操作系统内核。

   *   **c. 形成物理地址:**
       *   一旦获得了物理页框号(PFN)，MMU会将其与逻辑地址中的 **页内偏移 (Offset)** 拼接起来，形成最终的 **物理地址 (Physical Address)**，然后通过总线访问该地址。

   **2. 软件行为 (操作系统缺页异常处理)**

   当硬件触发缺页异常后，CPU会切换到 **内核态**，并跳转执行操作系统预设的 **缺页异常处理程序 (Page Fault Handler)**：

   *   **a. 分析异常:** 内核首先分析异常原因。
       *   如果是 **非法访问** (如权限错误)，内核会向该进程发送一个信号 (如 `SIGSEGV`)，通常导致进程被终止。
       *   如果是 **页面确实不在内存中**，则进入下一步。

   *   **b. 调入页面:**
       *   内核在磁盘的交换空间 (Swap Space) 或内存映射文件中找到该页面。
       *   在物理内存中寻找一个 **空闲页框**。若没有空闲页框，则执行 **页面置换算法 (如LRU, Clock)** 来选择一个"牺牲"页框。
       *   如果牺牲页框是"脏"的 (Dirty Bit = 1)，即被修改过，必须先将其内容 **写回磁盘**。
       *   内核发起I/O请求，将所需的页面从磁盘 **读入** 到选定的物理页框中。

   *   **c. 更新页表并返回:**
       *   页面从磁盘加载完成后，内核会 **更新页表项(PTE)**，填入新的物理页框号，并将有效位置为1。
       *   内核处理完成，返回到用户态。硬件会 **重新执行** 之前导致异常的指令。

   **总结:** 硬件(MMU)负责快速的、常规的地址转换；当硬件无法处理时 (即缺页)，它就"求助"于软件(操作系统)来处理复杂的加载和替换逻辑。这个过程完美体现了软硬件协同工作的设计思想。

2. 解释这张图中的每个箭头（约10个），并说明该图反映了何种设计思想。

   <img src="./2015-期末-回忆-有答案.assets/CleanShot 2025-06-08 at 00.04.45@2x.png" alt="CleanShot 2025-06-08 at 00.04.45@2x" style="zoom:30%;" />

3. 解释这张图所体现的设计思想。

   <img src="./2015-期末-回忆-有答案.assets/CleanShot 2025-06-08 at 00.05.08@2x.png" alt="CleanShot 2025-06-08 at 00.05.08@2x" style="zoom:30%;" />

## 四、存储系统 (共20分)

1.  说明Unix文件系统中不同功能区块的名称及其作用（例如：空闲区、i-node节点区、根目录区等）。
2.  绘制一个与Unix文件系统相关的结构图。
3.  计算删除一个文件需要访问磁盘的次数。

## 五、死锁 (共10分)

1.  给定一个系统状态，判断在执行某个操作后，系统是否仍处于安全状态。

这里给出课上例题作为参考。

5个进程 (P1-P5)，3类资源 (A,B,C)。

|        | 已分配 (Allocation) | 最大需求 (Max) | 尚需要 (Need) |
| :----- | :-----------------: | :------------: | :-----------: |
|        |        A B C        |     A B C      |     A B C     |
| **P1** |        0 1 0        |     7 5 3      |     7 4 3     |
| **P2** |        2 0 0        |     3 2 2      |     1 2 2     |
| **P3** |        3 0 2        |     9 0 2      |     6 0 0     |
| **P4** |        2 1 1        |     2 2 2      |     0 1 1     |
| **P5** |        0 0 2        |     4 3 3      |     4 3 1     |

给定一个系统状态，判断：
1.  此状态是否为安全状态？
2.  P2申请(1,0,2)能否分配？
3.  P5申请(3,3,0)能否分配？
4.  P1申请(0,2,0)能否分配？

**解答**:

**1. 判断当前状态是否安全**

使用安全性算法。`Work = Available = (3,3,2)`。`Finish = {F,F,F,F,F}`。
* **Step 1**: 找一个 `Need[i] <= Work` 的进程。
    * P1? (7,4,3) > (3,3,2) No
    * P2? (1,2,2) <= (3,3,2) Yes. P2可以执行。
    * `Work = Work + Allocation[P2] = (3,3,2) + (2,0,0) = (5,3,2)`. `Finish[P2]=T`.
* **Step 2**:
    * P1? (7,4,3) > (5,3,2) No
    * P3? (6,0,0) > (5,3,2) No
    * P4? (0,1,1) <= (5,3,2) Yes. P4可以执行。
    * `Work = Work + Allocation[P4] = (5,3,2) + (2,1,1) = (7,4,3)`. `Finish[P4]=T`.
* **Step 3**:
    * P1? (7,4,3) <= (7,4,3) Yes. P1可以执行。
    * `Work = Work + Allocation[P1] = (7,4,3) + (0,1,0) = (7,5,3)`. `Finish[P1]=T`.
* **Step 4**:
    * P3? (6,0,0) <= (7,5,3) Yes. P3可以执行。
    * `Work = Work + Allocation[P3] = (7,5,3) + (3,0,2) = (10,5,5)`. `Finish[P3]=T`.
* **Step 5**:
    * P5? (4,3,1) <= (10,5,5) Yes. P5可以执行。
    * `Work = Work + Allocation[P5] = (10,5,5) + (0,0,2) = (10,5,7)`. `Finish[P5]=T`.
    所有进程都可执行完毕，所以 **当前状态是安全的**。一个安全序列是 **<P2, P4, P1, P3, P5>**。

**2. P2申请 (1,0,2)**
* **检查1**: `Request[P2] <= Need[P2]`? (1,0,2) <= (1,2,2) Yes.
* **检查2**: `Request[P2] <= Available`? (1,0,2) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (1,0,2) = (2,3,0)`
    * `Allocation[P2] = (2,0,0) + (1,0,2) = (3,0,2)`
    * `Need[P2] = (1,2,2) - (1,0,2) = (0,2,0)`
* **安全性检查**: 新状态下的 `Work = (2,3,0)`.
    * P2? `Need=(0,2,0) <= (2,3,0)` Yes. `Work = (2,3,0)+(3,0,2) = (5,3,2)`.
    * P4? `Need=(0,1,1) <= (5,3,2)` Yes. `Work = (5,3,2)+(2,1,1) = (7,4,3)`.
    * P1? `Need=(7,4,3) <= (7,4,3)` Yes. `Work = (7,4,3)+(0,1,0) = (7,5,3)`.
    * P3? `Need=(6,0,0) <= (7,5,3)` Yes. `Work = (7,5,3)+(3,0,2) = (10,5,5)`
    * P5? `Need=(4,3,1) <= (10,5,5)` Yes.
    * 系统仍然安全。所以 **可以分配**。

**3. P5申请 (3,3,0)**
* **检查1**: `Request[P5] <= Need[P5]`? (3,3,0) <= (4,3,1) Yes.
* **检查2**: `Request[P5] <= Available`? (3,3,0) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (3,3,0) = (0,0,2)`
    * `Allocation[P5] = (0,0,2) + (3,3,0) = (3,3,2)`
    * `Need[P5] = (4,3,1) - (3,3,0) = (1,0,1)`
* **安全性检查**: 新状态下的 `Work = (0,0,2)`.
    * 此时，没有一个进程的`Need`向量小于等于`Work`向量。系统进入不安全状态。
    * 所以 **不能分配**。

**4. P1申请 (0,2,0)**
* **检查1**: `Request[P1] <= Need[P1]`? (0,2,0) <= (7,4,3) Yes.
* **检查2**: `Request[P1] <= Available`? (0,2,0) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (0,2,0) = (3,1,2)`
    * `Allocation[P1] = (0,1,0) + (0,2,0) = (0,3,0)`
    * `Need[P1] = (7,4,3) - (0,2,0) = (7,2,3)`
* **安全性检查**: 新状态下的 `Work = (3,1,2)`.
    * P1? No. P2? No. P3? No. P4? (0,1,1) <= (3,1,2) Yes.
    * `Work = (3,1,2) + (2,1,1) = (5,2,3)`
    * P2? `Need=(1,2,2) <= (5,2,3)` Yes. `Work = (5,2,3) + (2,0,0) = (7,2,3)`
    * P1? `Need=(7,2,3) <= (7,2,3)` Yes. `Work = (7,2,3) + (0,3,0) = (7,5,3)`
    * P3? `Need=(6,0,0) <= (7,5,3)` Yes. `Work = (7,5,3) + (3,0,2) = (10,5,5)`
    * P5? `Need=(4,3,1) <= (10,5,5)` Yes.
    * 系统仍然安全。所以 **可以分配**。

1.  以哲学家就餐问题为例，简述如何预防死锁。

## 六、同步问题 (共10分)

1.  **生产者-消费者问题**:
    - 资源总数为 K。
    - 特殊要求：某个消费者必须等待另一个消费者取完5个资源后，才能开始获取资源。
    - 要求使用P、V（信号量）操作解决该同步问题。
