# 2018年秋季学期操作系统期末考试题目总结

## 第一大题：简答题 (共6问, 30分)

1. 关于中断向量表：一个支持100个 system call 的操作系统是如何实现的？

2. 进程通过 `fopen` 系统调用读取文件的过程与 PCB (进程控制块)、FCB (文件控制块) 的关系是什么？

3. 虚拟内存技术中的 Page Table Entry (页表项) 包含哪些内容？为何这样设计？

4. 存储管理中的 Invert Page Table (反向页表) 的设计思路是什么？它如何将虚拟地址转化为物理地址？

5. 根据课件12 (文件模型2) 第23页的图，阐述其体现的设计思想。不知道是什么图可能是这个:

   <img src="./2018秋-期末-回忆-有答案.assets/CleanShot 2025-06-08 at 00.05.08@2x.png" alt="CleanShot 2025-06-08 at 00.05.08@2x" style="zoom:30%;" />

6. 内存映射编址 (Memory-mapped I/O) 和 I/O 独立编址 (Port-mapped I/O) 的区别是什么？

## 第二大题：存储管理 (共2问, 20分)

1. 关于 Windows 虚拟存储管理：

   <img src="./2018秋-期末-回忆-有答案.assets/CleanShot 2025-06-08 at 00.20.09@2x.png" alt="CleanShot 2025-06-08 at 00.20.09@2x" style="zoom:30%;" />

   *   解释以下页面状态转换分别对应什么场景：
       *   工作集 → 空闲 (Working Set → Free)
       *   空闲 → 工作集 (Free → Working Set)
       *   工作集 → 后备 (Working Set → Standby)
       *   工作集 → 修改 (Working Set → Modified)
       *   后备 → 工作集 (Standby → Working Set)
       *   修改 → 工作集 (Modified → Working Set)
   *   这些转换体现了什么设计思路？

2. 请详细写出 Copy-on-Write (写时复制) 技术的实现细节，包括设计思路和所用到的数据结构。

## 第三大题：文件管理 (共3问, 24分)

1.  为一块 32 GB 的 U 盘设计一个文件系统，需满足以下要求：
    *   可从 U 盘启动。
    *   每个磁盘块大小为 1024 B。
    *   最大支持 2 GB 的文件大小。
    *   空闲块管理只使用一个磁盘块。
    *   支持随机访问。
    *   注重文件性能。
2.  画出进行一系列指定文件操作后，磁盘块的最终布局。

这里给出课上例题作为参考。

*   假设一块刚格式化好的磁盘大小为 2MB；每块/簇 大小为 512 字节。
*   要求画出 (或描述) 在执行下列操作后，一个简化的 UNIX 文件系统和一个 FAT16 文件系统的布局。
*   操作序列:
    1.  `mkdir /A`
    2.  `mkdir /A/B`
    3.  `create /A/B/File1` (占用 4 块/簇)
    4.  `mkdir /C`
    5.  `mkdir /D`
    6.  `mkdir /C/E`
    7.  `create /C/E/File2` (占用 16 块/簇)
    8.  `mkdir /C/E/F`
    9.  `create /C/E/F/File3` (占用 8 块/簇)
    10. `create /C/E/F/File4` (占用 2 块/簇)

**解答**:

UNIX:

<img src="./2018秋-期末-回忆-有答案.assets/UNIX.jpeg" alt="UNIX" style="zoom:50%;" />

FAT16:

<img src="./2018秋-期末-回忆-有答案.assets/FAT16.jpeg" alt="FAT16" style="zoom:50%;" />

3.  阐述你的设计中：
    *   如何寻找根目录的起始地址？
    *   如何提升文件系统的性能？
    *   读取某个文件的某个特定字节需要多少次磁盘块操作？

## 第四大题：死锁 (共2问, 16分)

1.  死锁预防的思路是什么？如何将这种思路应用在哲学家就餐问题上？
2.  给出一个系统资源状态，判断：
    *   当前系统是否处于安全状态？
    *   此时一个进程发出的资源申请能否被批准？

这里给出课上例题作为参考。

5个进程 (P1-P5)，3类资源 (A,B,C)。

|        | 已分配 (Allocation) | 最大需求 (Max) | 尚需要 (Need) |
| :----- | :-----------------: | :------------: | :-----------: |
|        |        A B C        |     A B C      |     A B C     |
| **P1** |        0 1 0        |     7 5 3      |     7 4 3     |
| **P2** |        2 0 0        |     3 2 2      |     1 2 2     |
| **P3** |        3 0 2        |     9 0 2      |     6 0 0     |
| **P4** |        2 1 1        |     2 2 2      |     0 1 1     |
| **P5** |        0 0 2        |     4 3 3      |     4 3 1     |

给定一个系统状态，判断：
1.  此状态是否为安全状态？
2.  P2申请(1,0,2)能否分配？
3.  P5申请(3,3,0)能否分配？
4.  P1申请(0,2,0)能否分配？

**解答**:

**1. 判断当前状态是否安全**

使用安全性算法。`Work = Available = (3,3,2)`。`Finish = {F,F,F,F,F}`。
* **Step 1**: 找一个 `Need[i] <= Work` 的进程。
    * P1? (7,4,3) > (3,3,2) No
    * P2? (1,2,2) <= (3,3,2) Yes. P2可以执行。
    * `Work = Work + Allocation[P2] = (3,3,2) + (2,0,0) = (5,3,2)`. `Finish[P2]=T`.
* **Step 2**:
    * P1? (7,4,3) > (5,3,2) No
    * P3? (6,0,0) > (5,3,2) No
    * P4? (0,1,1) <= (5,3,2) Yes. P4可以执行。
    * `Work = Work + Allocation[P4] = (5,3,2) + (2,1,1) = (7,4,3)`. `Finish[P4]=T`.
* **Step 3**:
    * P1? (7,4,3) <= (7,4,3) Yes. P1可以执行。
    * `Work = Work + Allocation[P1] = (7,4,3) + (0,1,0) = (7,5,3)`. `Finish[P1]=T`.
* **Step 4**:
    * P3? (6,0,0) <= (7,5,3) Yes. P3可以执行。
    * `Work = Work + Allocation[P3] = (7,5,3) + (3,0,2) = (10,5,5)`. `Finish[P3]=T`.
* **Step 5**:
    * P5? (4,3,1) <= (10,5,5) Yes. P5可以执行。
    * `Work = Work + Allocation[P5] = (10,5,5) + (0,0,2) = (10,5,7)`. `Finish[P5]=T`.
    所有进程都可执行完毕，所以 **当前状态是安全的**。一个安全序列是 **<P2, P4, P1, P3, P5>**。

**2. P2申请 (1,0,2)**
* **检查1**: `Request[P2] <= Need[P2]`? (1,0,2) <= (1,2,2) Yes.
* **检查2**: `Request[P2] <= Available`? (1,0,2) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (1,0,2) = (2,3,0)`
    * `Allocation[P2] = (2,0,0) + (1,0,2) = (3,0,2)`
    * `Need[P2] = (1,2,2) - (1,0,2) = (0,2,0)`
* **安全性检查**: 新状态下的 `Work = (2,3,0)`.
    * P2? `Need=(0,2,0) <= (2,3,0)` Yes. `Work = (2,3,0)+(3,0,2) = (5,3,2)`.
    * P4? `Need=(0,1,1) <= (5,3,2)` Yes. `Work = (5,3,2)+(2,1,1) = (7,4,3)`.
    * P1? `Need=(7,4,3) <= (7,4,3)` Yes. `Work = (7,4,3)+(0,1,0) = (7,5,3)`.
    * P3? `Need=(6,0,0) <= (7,5,3)` Yes. `Work = (7,5,3)+(3,0,2) = (10,5,5)`.
    * P5? `Need=(4,3,1) <= (10,5,5)` Yes.
    * 系统仍然安全。所以 **可以分配**。

**3. P5申请 (3,3,0)**
* **检查1**: `Request[P5] <= Need[P5]`? (3,3,0) <= (4,3,1) Yes.
* **检查2**: `Request[P5] <= Available`? (3,3,0) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (3,3,0) = (0,0,2)`
    * `Allocation[P5] = (0,0,2) + (3,3,0) = (3,3,2)`
    * `Need[P5] = (4,3,1) - (3,3,0) = (1,0,1)`
* **安全性检查**: 新状态下的 `Work = (0,0,2)`.
    * 此时，没有一个进程的`Need`向量小于等于`Work`向量。系统进入不安全状态。
    * 所以 **不能分配**。

**4. P1申请 (0,2,0)**
* **检查1**: `Request[P1] <= Need[P1]`? (0,2,0) <= (7,4,3) Yes.
* **检查2**: `Request[P1] <= Available`? (0,2,0) <= (3,3,2) Yes.
* **假定分配**:
    * `Available = (3,3,2) - (0,2,0) = (3,1,2)`
    * `Allocation[P1] = (0,1,0) + (0,2,0) = (0,3,0)`
    * `Need[P1] = (7,4,3) - (0,2,0) = (7,2,3)`
* **安全性检查**: 新状态下的 `Work = (3,1,2)`.
    * P1? No. P2? No. P3? No. P4? (0,1,1) <= (3,1,2) Yes.
    * `Work = (3,1,2) + (2,1,1) = (5,2,3)`
    * P2? `Need=(1,2,2) <= (5,2,3)` Yes. `Work = (5,2,3) + (2,0,0) = (7,2,3)`
    * P1? `Need=(7,2,3) <= (7,2,3)` Yes. `Work = (7,2,3) + (0,3,0) = (7,5,3)`
    * P3? `Need=(6,0,0) <= (7,5,3)` Yes. `Work = (7,5,3) + (3,0,2) = (10,5,5)`
    * P5? `Need=(4,3,1) <= (10,5,5)` Yes.
    * 系统仍然安全。所以 **可以分配**。

## 第五大题：同步互斥机制 (共1问, 10分)

1.  设计一个管程 (Monitor) 来实现以下同步互斥问题：
    *   一个仓库中保存两种材料 A 和 B，每种材料的最大库存量为 M。
    *   有两个生产者分别提供材料 A 和 B。
    *   有两个消费者分别取用材料 A 和 B。
    *   规定：
        *   库存的材料必须先进先出 (FIFO)。
        *   当一种材料的库存比另一种多出 N 个时 (N < M)，暂停该材料的生产。
    *   要求写出完整的管程实现代码。 