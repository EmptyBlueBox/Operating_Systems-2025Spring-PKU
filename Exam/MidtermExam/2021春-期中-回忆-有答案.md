# 2021年春季学期操作系统期中考试题目总结

## 一、 环境和运行机制、系统调用 (30 分)

1.  请列举五条需要在保护模式下运行的指令。"访管指令"需要在保护模式下执行吗？为什么？ (10 分)

   需要在保护模式下运行的指令：LGDT (加载全局描述符表寄存器) 、LIDT (加载中断描述符表寄存器) 、MOV CR0 (修改控制寄存器) 、CLI (清中断标志) 、LTR (加载任务寄存器) 。
   
   访管指令必须在保护模式下执行。因为访管指令涉及特权级转换，需要保护模式提供的特权级机制来确保安全，实模式下无法提供这种保护。

2.  描述从接收中断/异常到中断处理程序运行结束，处理中断/异常的过程，并指出哪些是硬件实现的？哪些是操作系统实现的？中断处理程序执行结束后，需要执行哪一个模块 (哪一过程) ？操作系统初始化和中断有什么关系？ (10 分)

   处理中断/异常的过程：
   1. 硬件保存当前上下文 (保存标志寄存器、CS、IP等) 
   2. 硬件根据中断向量查找IDT，获取中断处理程序入口地址
   3. 硬件切换到内核态，跳转到中断处理程序
   4. 操作系统保存其他现场 (寄存器等) 
   5. 操作系统执行具体中断处理程序
   6. 操作系统恢复现场
   7. 硬件执行IRET指令，恢复标志寄存器、CS、IP等，返回被中断的程序

   硬件实现：1-3和7步骤；操作系统实现：4-6步骤。
   
   中断处理程序结束后执行中断返回例程。
   
   操作系统初始化需要设置中断描述符表，初始化中断控制器，为系统提供中断处理的基础设施。

3.  为了实现系统调用机制，系统要做哪些工作？ (10 分)

   实现系统调用机制需要：
   1. 定义系统调用接口和编号
   2. 实现用户态到内核态的特权级切换 (通常通过软中断实现) 
   3. 提供系统调用表，将调用编号映射到对应的内核函数
   4. 实现参数传递机制 (通过寄存器或栈) 
   5. 实现返回值传递机制
   6. 提供用户库封装系统调用 (如libc) 
   7. 实现权限检查和安全控制

## 二、 进程线程模型 (20 分)

1.  请画出五状态进程模型，包括状态的名称以及转移条件。 (10 分)

   五状态进程模型：
   - 新建 (New) ：进程刚被创建
   - 就绪 (Ready) ：进程等待被调度
   - 运行 (Running) ：进程正在执行
   - 阻塞 (Blocked) ：进程等待某事件发生
   - 终止 (Terminated) ：进程执行完毕

   状态转移：
   - 新建→就绪：进程创建完成，系统接纳
   - 就绪→运行：调度器选择执行
   - 运行→就绪：时间片用完或高优先级进程抢占
   - 运行→阻塞：进程等待资源或I/O操作
   - 阻塞→就绪：等待事件发生或资源可用
   - 运行→终止：进程执行完毕或被强制终止

2.  线程和进程有什么区别？线程有什么属性？为什么线程要有自己的栈？线程的实现方式有哪几种？典型的操作系统是通过什么方式实现线程的？ (10 分)

   区别：
   - 进程是资源分配的基本单位，线程是CPU调度的基本单位
   - 同一进程内的线程共享地址空间和资源，进程间相互独立
   - 线程切换开销小于进程切换
   - 线程没有独立的地址空间，进程有

   线程属性：线程ID、程序计数器、寄存器集合、栈、状态、优先级

   线程需要自己的栈是因为：每个线程执行不同的函数调用序列，需要独立的栈来保存局部变量、返回地址和函数参数，确保函数调用的正确执行。

   线程实现方式：用户级线程 (在用户空间实现) 、内核级线程 (在内核中实现) 、混合实现 (两种方式结合) 。

   典型操作系统通过内核级线程实现线程机制，如Windows、Linux等。

## 三、 进程调度 (25 分)

1.  现在有三个进程，A、B 和 C。A 和 B 的运行时间是 1000ms (全部在 CPU 上进行计算) ，C 进程是一个无限循环，在每个循环中，会先使用处理器 1ms，然后再花 10ms 使用 I/O。请写出在以下几种调度算法下进程的调度状态，并对每个调度算法对本任务的调度进行分析和评价。调度算法分别为：先来先服务算法、时间片轮转算法 (时间片分别为 100ms 和 1ms) 、SRTN (最短剩余时间优先算法) 。 (10 分)

   先来先服务(FCFS)：
   假设顺序为A→B→C
   - A运行1000ms完成
   - B运行1000ms完成
   - C无限循环运行
   
   评价：A、B进程有固定完成时间，但C的响应性很差，要等待2000ms才能首次运行。对I/O密集型进程不友好。

   时间片轮转(RR)，时间片=100ms：
   - A运行100ms，还剩900ms
   - B运行100ms，还剩900ms
   - C运行1ms后进入I/O等待
   - I/O过程中可调度A、B
   - 以此类推

   评价：公平性好，A和B需要20轮才能完成，总完成时间约为2000ms。C获得较好响应性。

   时间片轮转(RR)，时间片=1ms：
   - A运行1ms，还剩999ms
   - B运行1ms，还剩999ms
   - C运行1ms后进入I/O等待
   - 循环往复
   
   评价：频繁切换造成巨大开销，但C进程响应性最佳，可以充分利用I/O和CPU并行。

   SRTN：
   - C的CPU时间短(每次1ms)，优先运行C
   - C执行后I/O时，A和B竞争
   - 当A和B剩余时间相等时，随机选择
   
   评价：C获得最好的响应性，但A和B可能出现饥饿，因为C无限循环。

2.  请设计一个基于多级反馈队列的调度算法，描述你的算法并回答以下问题： (15 分)
    (1) 你设计的算法是抢占的还是非抢占的？为什么？
    (2) 你设计的算法对 I/O 密集型和 CPU 密集型进程哪个更友好？说明你的原因。
    (3) 你是如何处理进程等待 I/O 后再次被调度上 CPU 时要继续运行的时间片大小的？
    (4) 你设计的算法会导致"饥饿"问题吗？为什么会有这个问题？如果产生了"饥饿"的问题，要用什么方法解决？

   多级反馈队列调度算法设计：
   - 设置三个队列：Q0、Q1、Q2，优先级依次降低
   - Q0时间片为4ms，Q1为8ms，Q2为16ms
   - 新进程先进入Q0
   - 进程在当前队列未用完时间片时被抢占，重新排队
   - 用完时间片的进程进入下一级队列
   - 最后一级队列(Q2)采用FCFS策略
   - 每隔100ms将所有进程重新放入Q0
   
   (1) 该算法是抢占式的。因为新进入高优先级队列的进程可以抢占低优先级队列中运行的进程，提高系统响应性和交互性能。
   
   (2) 该算法对I/O密集型进程更友好。I/O密集型进程通常在短时间内就会因等待I/O而主动放弃CPU，未用完时间片，当它们的I/O完成后，会重新进入高优先级队列，获得更高的调度优先权；而CPU密集型进程通常会用完时间片，逐渐降到低优先级队列。
   
   (3) 最高优先级进程等待I/O后再次被调度上CPU时，会进入最高优先级队列(Q0)，重新获得短时间片。这样设计是因为刚完成I/O的进程可能立即需要CPU进行处理，赋予较高优先级可提高系统吞吐量。
   
   (4) 该算法可能导致饥饿问题。CPU密集型进程可能被持续推至最低优先级队列，而频繁的I/O操作进程一直占据高优先级队列。解决方法是定期将所有进程提升到最高优先级队列 (已在算法中设计为每100ms一次) ，确保每个进程都有公平的执行机会。

## 四、 进程同步 (25 分)

1.  不同的操作系统为实现进程同步提供了不同的机制。锁和条件变量的机制分别能解决什么问题？如果用锁和条件变量来解决生产者-消费者问题，需要注意哪一点？ (5 分)

   锁能解决互斥访问问题，确保同一时间只有一个线程可以访问共享资源，防止并发访问导致的数据不一致。

   条件变量能解决线程间同步和通信问题，允许线程等待某个条件满足，并在条件满足时被其他线程唤醒。
   
   使用锁和条件变量解决生产者-消费者问题时，需要注意在检查条件和执行后续操作之间可能发生的"虚假唤醒"，应使用while循环而非if语句检查条件；同时要避免死锁，确保锁的获取和释放正确配对。

**以下 2、3、4 三道用信号量和 PV 操作解决的问题中，任选一道题进行作答。如果多选，按所答的第一道题评分。**

2.  (10 分) 邱德拔体育馆内有一个羽毛球场地，供若干学生练习羽毛球。现在是双打练习时间，每四个学生组成一队，占用球场练习。
    **要求：**
    如果不足四个学生，则不能开展双打练习；如果四个学生练习了足够时间，则一起离开球场，此时，可以让其他等待的学生利用羽毛球场地进行练习。
    体育教研室会安排一个裁判进行评分 (没有学生练习，裁判在休息室休息) 。
    请用信号量及 PV 操作正确完成羽毛球场地的使用过程。

    **答**: 
    **1. 信号量及变量说明**
    *   `semaphore mutex = 1;`: 二元信号量，用于保护对 `waiting_count` 计数器的互斥访问。
    *   `int waiting_count = 0;`: 共享变量，记录已到达并等待组队的学生的数量。
    *   `semaphore entry_barrier = 0;`: 同步信号量，用作一个栅栏，阻止学生开始比赛，直到凑齐4个人。
    *   `semaphore court = 1;`: 二元信号量，代表羽毛球场地，初始值为1，确保同一时间只有一队（4名学生）可以使用场地。
    *   `semaphore game_starts = 0;`: 同步信号量，由学生在比赛开始时通知裁判。
    *   `semaphore game_ends = 0;`: 同步信号量，由学生在比赛结束时通知裁判。
    *   `semaphore exit_mutex = 1;`: 二元信号量，用于保护对 `leaving_count` 计数器的互斥访问。
    *   `int leaving_count = 0;`: 共享变量，记录已完成比赛并准备离开的学生的数量。
    *   `semaphore exit_barrier = 0;`: 同步信号量，用作第二个栅栏，确保一个队伍的4名学生全部同时离开。

    **2. 进程伪代码**
    ```c++
    // 学生进程
    void Student() {
        // --- 阶段一: 到达并组队 ---
        P(mutex);
        waiting_count++;
        if (waiting_count == 4) {   // 第4名学生到达，队伍组成
            waiting_count = 0;      // 为下一队重置计数器
            P(court);               // 队伍占用场地
            V(game_starts);         // 通知裁判比赛开始
            // 打开入口栅栏，让所有4名学生通过
            V(entry_barrier); V(entry_barrier); V(entry_barrier); V(entry_barrier);
        }
        V(mutex);

        P(entry_barrier);           // 所有学生在此等待，直到凑齐4人且场地可用

        // --- 进行羽毛球练习 ---
        // playing_badminton();
        
        // --- 阶段二: 一起离开 ---
        P(exit_mutex);
        leaving_count++;
        if (leaving_count == 4) {   // 队伍中最后一名学生准备离开
            leaving_count = 0;      // 为下一队重置计数器
            V(game_ends);           // 通知裁判比赛结束
            // 打开出口栅栏，让所有4名学生离开
            V(exit_barrier); V(exit_barrier); V(exit_barrier); V(exit_barrier);
            V(court);               // 队伍完全离开后，释放场地
        }
        V(exit_mutex);
        
        P(exit_barrier);            // 所有学生在此等待，直到全队都准备好离开
    }

    // 裁判进程
    void Referee() {
        while (true) {
            P(game_starts);         // 等待比赛开始的信号

            // --- 裁判进行评分工作 ---
            // referee_is_scoring();

            P(game_ends);           // 等待比赛结束的信号
            
            // --- 裁判返回休息室休息 ---
            // referee_is_resting();
        }
    }
    ```

3.  (10 分) 现在有一条河南有南北两岸，河上有 N 个石墩，每个石墩上只能有一个人，要求在过河时只能有单向的人过河 (类似于三峡大坝问题，具体记不清了) 。
    (1) 使用信号量和 PV 操作正确解决这个问题。
    (2) 如果从南边来的人多，要求优先满足南边的人的过河需求，应该做怎样的改动？

    **答**: 
    这个问题是"读者-写者问题"的一个经典变体，具体来说是"两组读者互斥"问题，其中"读者"是从一个方向过河的人，"写者"（或另一组"读者"）是从另一个方向过河的人。每个石墩是独立的互斥资源。

    ### (1) 公平过河方案 (无优先级)

    这类似于三峡大坝或狒狒过峡谷问题，核心是保证同一时间只有一个方向的人在过河。

    #### 1. 信号量和变量设置
    *   `stones[N]`: 信号量数组，`stones[i]` 代表第 `i` 个石墩的使用权，初始值均为 1。
    *   `direction_mutex`: 关键的方向互斥信号量，确保单向通行，初始值为 1。
    *   `north_mutex`, `south_mutex`: 分别保护南北向过河人数计数的互斥锁，初始值为 1。
    *   `north_count`, `south_count`: 计数器，记录当前正在河上的南北向人数，初始值为 0。

    #### 2. 伪代码实现
    ```c++
    // --- 信号量和共享变量 ---
    semaphore stones[N]; // 假设已全部初始化为1
    semaphore direction_mutex = 1;
    semaphore north_mutex = 1, south_mutex = 1;
    int north_count = 0, south_count = 0;

    // --- 从南向北过河的人 ---
    void SouthToNorth_Process() {
        /*
         * Function: 模拟一个从南向北的人的过河过程。
         *           这是经典的读者-写者问题中的"读者"进入/退出协议。
         */
        // 1. 进入协议 (请求方向)
        P(north_mutex);
        if (north_count == 0) { // 如果是第一个从北向的人
            P(direction_mutex); // 尝试获取过河方向，可能会因对向有人而等待
        }
        north_count++;
        V(north_mutex);

        // 2. 过河 (互斥访问石墩)
        P(stones[0]);
        // 到达第0个石墩
        for (int i = 1; i < N; i++) {
            P(stones[i]);
            // 到达第i个石墩，可以释放前一个石墩了
            V(stones[i-1]);
        }
        V(stones[N-1]); // 离开最后一个石墩

        // 3. 退出协议 (释放方向)
        P(north_mutex);
        north_count--;
        if (north_count == 0) { // 如果是最后一个从北向的人
            V(direction_mutex); // 释放过河方向，允许对向过河
        }
        V(north_mutex);
    }

    // --- 从北向南过河的人 (逻辑对称) ---
    void NorthToSouth_Process() {
        /*
         * Function: 模拟一个从北向南的人的过河过程。
         */
        // 1. 进入协议 (请求方向)
        P(south_mutex);
        if (south_count == 0) {
            P(direction_mutex);
        }
        south_count++;
        V(south_mutex);

        // 2. 过河 (方向相反)
        P(stones[N-1]);
        for (int i = N-2; i >= 0; i--) {
            P(stones[i]);
            V(stones[i+1]);
        }
        V(stones[0]);

        // 3. 退出协议 (释放方向)
        P(south_mutex);
        south_count--;
        if (south_count == 0) {
            V(direction_mutex);
        }
        V(south_mutex);
    }
    ```

    ### (2) 南边优先过河方案

    为实现"南边优先"，我们需要实现"写者优先"的读者-写者模型。这里，我们将从南向北的人视为"写者"（高优先级），从北向南的人视为"读者"（低优先级）。

    #### 1. 信号量和变量设置 (新增/修改)
    *   `south_gate`: 一个"闸门"信号量，由南边的人控制。当有南边的人想要过河时，会关上此"闸门"，阻止所有北边的人开始过河。初始值为 1。
    *   `south_waiting_count`: 记录正在**等待**过河的南边人数。这是实现优先级的关键。
    *   `mutex_sw`: 保护 `south_waiting_count` 的互斥锁。

    #### 2. 伪代码实现

    ```c++
    // --- 信号量和共享变量 ---
    // (stones, direction_mutex, north_mutex, south_mutex, north_count, south_count 不变)
    semaphore south_gate = 1;
    semaphore mutex_sw = 1;
    int south_waiting_count = 0;

    // --- 从北向南过河的人 (读者/低优先级) ---
    void NorthToSouth_Process_LowPriority() {
        P(south_gate); // 1. 尝试通过南边人控制的闸门
        
        // 2. 进入协议 (与公平方案相同)
        P(north_mutex);
        if (north_count == 0) {
            P(direction_mutex);
        }
        north_count++;
        V(north_mutex);
        
        V(south_gate); // 3. 尽快释放闸门，让其他北向的同伴也能尝试进入

        // 4. 过河 (不变)
        // ... crossing stones ...

        // 5. 退出协议 (不变)
        P(north_mutex);
        north_count--;
        if (north_count == 0) {
            V(direction_mutex);
        }
        V(north_mutex);
    }

    // --- 从南向北过河的人 (写者/高优先级) ---
    void SouthToNorth_Process_HighPriority() {
        // 1. 写者优先进入协议
        P(mutex_sw);
        south_waiting_count++;
        if (south_waiting_count == 1) { // 如果是第一个等待的南边人
            P(south_gate); // 立刻关上北边人的闸门
        }
        V(mutex_sw);

        // 2. 获取资源方向锁
        P(south_mutex);
        if (south_count == 0) {
            P(direction_mutex);
        }
        south_count++;
        V(south_mutex);

        // 3. 过河
        // ... crossing stones ...

        // 4. 释放资源方向锁
        P(south_mutex);
        south_count--;
        if (south_count == 0) {
            V(direction_mutex);
        }
        V(south_mutex);

        // 5. 写者优先退出协议
        P(mutex_sw);
        south_waiting_count--;
        if (south_waiting_count == 0) { // 如果是最后一个等待的南边人
            V(south_gate); // 重新打开北边人的闸门
        }
        V(mutex_sw);
    }
    ```
    #### 3. 工作原理解释

    此方案的核心是增加了一个由南边人（高优先级）控制的`south_gate`信号量。

    *   **南边人如何获得优先权**: 当第一个南边的人（我们称之为S1）想要过河时，他会立即执行 `P(south_gate)`，将"闸门"关闭。这会导致任何后续想过河的北边人（N1, N2...）在尝试通过`south_gate`时被阻塞。即使此时河上还有北边的人正在过河，新来的北边人也无法开始。S1和其他南边的同伴会等待河道清空（即等待`direction_mutex`被释放），然后开始过河。

    *   **南边优先权的持续**: 只要还有任何南边的人在等待（`south_waiting_count > 0`），`south_gate`就会保持关闭状态。这意味着，在南边的人流没有完全处理完之前，北边的人是不允许开始过河的。

    *   **优先权的释放**: 当最后一个南边的人（指最后一个表达了过河意愿的人）也完成了他的过河过程后，他会发现 `south_waiting_count` 减为了0，这时他才会执行 `V(south_gate)`，将"闸门"打开，从而允许被阻塞的北边人开始竞争过河。

4.  (10 分) 有一个系统，定义 P、V 操作如下：

    ```c++
    P(s):
        s.count--;
        if s<0 then
            将本进程插入相应队列末尾等待;

    V(s):
        s.count++;
        if s<=0 then
            从相应等待队列队尾唤醒一个进程，将其插入就绪队列;
    ```

    (1) 这样定义的 PV 操作会导致什么样的问题？
    (2) 用这样的 PV 操作正确实现 8 个进程访问临界区的互斥机制。
    (3) 对于 (2) 中的问题，请设计一个复杂度更低的解法。

   (1) 这种定义的PV操作会导致的问题：
   - 公平性问题：V操作从队尾唤醒进程，不符合先等待先服务原则
   - 可能导致进程饥饿：某些进程可能长时间无法获得资源
   - 不支持优先级调度：无法基于进程优先级进行调度
   - 互斥语义变化：与传统PV操作的互斥效果不同

   (2) 实现8个进程互斥访问临界区：
   ```c++
   // 信号量定义
   semaphore mutex = 8;  // 初始值设为进程数
   
   // 进程访问临界区
   void process(int id) {
       while(true) {
           P(mutex);  // 尝试进入临界区
           
           // 临界区
           critical_section();
           
           V(mutex);  // 离开临界区
           
           // 非临界区
           non_critical_section();
       }
   }
   ```

   这个解决方案中，互斥信号量初值设为8，表示最多允许8个进程同时访问临界区。由于题目要求的是互斥访问，我们需要确保一次只有一个进程在临界区，但此处的PV操作语义特殊，需要特别处理。

   (3) 复杂度更低的解法：
   ```c++
   // 信号量定义
   semaphore mutex = 1;  // 初始值为1
   
   // 进程访问临界区
   void process(int id) {
       while(true) {
           P(mutex);  // 尝试进入临界区
           
           // 临界区
           critical_section();
           
           V(mutex);  // 离开临界区
           
           // 非临界区
           non_critical_section();
       }
   }
   ```

   这个解法使用标准互斥信号量，初值为1，确保一次只有一个进程能访问临界区，复杂度更低，更容易理解和验证正确性。

5.  用管程模拟顾客进出超市的问题：(10 分)
    某物美超市有 100 辆购物推车，顾客进入时要刷会员卡领取一辆推车，如果超市没有空闲推车，则顾客在超市门口等待。顾客买完东西结账离开时需刷卡还回推车。

   ```c++
   class Supermarket {
       // 变量定义
       int free_carts = 100;  // 空闲购物车数量
       condition cart_available;  // 条件变量：有空闲购物车
       
       // 顾客获取购物车
       void get_cart() {
           while (free_carts == 0) {
               // 没有空闲购物车，等待
               cart_available.wait();
           }
           free_carts--;  // 减少一辆空闲购物车
       }
       
       // 顾客归还购物车
       void return_cart() {
           free_carts++;  // 增加一辆空闲购物车
           
           // 通知等待购物车的顾客
           cart_available.signal();
       }
   }
   
   // 顾客进程
   void customer(int id) {
       // 获取购物车
       Supermarket.get_cart();
       
       // 购物
       shopping();
       
       // 结账并归还购物车
       checkout();
       Supermarket.return_cart();
   }
   ```

   变量和条件变量作用：
   - free_carts：记录当前可用的购物车数量，初始值为100
   - cart_available：条件变量，表示有空闲购物车可用

**解答 PV 及管程题目的注意事项：**
1.  说明每一个信号量、条件变量或变量的作用；
2.  对代码的重点语句给予注释。

## 附加题：(6 分)

请描述一个现实生活中遇到的 IPC (进程间通信) 问题的场景，要求不与已经见到过的 IPC 问题的场景重复。

现实生活中的IPC场景：智能家居系统控制

在一个智能家居系统中，多个独立的控制程序 (相当于进程) 需要协同工作：
- 温度监控进程收集传感器数据并发送给中央控制系统
- 照明控制进程管理家中灯光
- 安全监控进程检测异常并发送警报
- 用户界面进程接收用户指令

这些进程需要高效通信以确保系统协调运行。例如，当用户通过手机APP (用户界面进程) 调整温度设置时，该指令需要传递给温度控制进程；当安全监控检测到异常，需要通知照明控制打开所有灯光并通知用户界面显示警报。

这种场景可通过消息队列实现进程间通信，各进程订阅相关主题，实现去中心化的事件驱动架构。与传统生产者-消费者或读写者问题不同，这是一个多对多的通信模型，各进程既可能是信息生产者也可能是消费者，通信关系更为复杂。
