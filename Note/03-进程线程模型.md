# 操作系统原理笔记

# 进程与线程模型问题解答

## 1. 怎样理解"进程是对CPU的抽象"这句话？
进程是对CPU的抽象，意味着进程为程序提供了一个假象：程序认为它独占了整个CPU资源。实际上，操作系统通过时分复用技术在多个进程间切换CPU，使每个进程都能获得CPU时间片，从而实现了多个进程"同时"运行的假象。这种抽象使程序员无需关心CPU调度细节，只需按顺序编写程序即可。

## 2. 何谓进程映像？进程有实体吗？在哪里？
进程映像是指进程在内存中的完整表示，包括代码段、数据段、堆栈段以及PCB(进程控制块)等。进程本身是一个抽象概念，没有实体，但其映像在内存中是实实在在存在的。进程的实体体现在：
- 内存中的进程映像
- 操作系统中的PCB数据结构
- 磁盘上的可执行文件

## 3. 怎样描述进程？一个进程都有什么（组成要素）？
一个完整的进程由以下组成要素构成：
- **PCB(进程控制块)**：包含进程标识符、状态、优先级等管理信息
- **程序代码**：可执行的指令集合
- **数据**：程序使用的变量、常量等
- **堆栈**：函数调用和局部变量存储区域
- **堆**：动态分配的内存区域
- **资源**：打开的文件、I/O设备等系统资源

## 4. 创建进程主要完成哪些工作？
创建进程主要完成以下工作：
1. 分配唯一的进程标识符(PID)
2. 为进程分配空间，创建PCB
3. 初始化PCB，设置进程的初始状态、优先级等信息
4. 分配进程所需的内存空间
5. 建立进程的地址空间(代码段、数据段、堆栈段)
6. 加载程序代码到内存
7. 初始化寄存器，包括程序计数器指向程序入口
8. 建立进程间的联系(如父子关系)
9. 将进程插入就绪队列，等待调度执行

## 5. 进程的生命周期内都会经历哪些变化？怎样表示这些变化？
进程的生命周期从创建开始，到终止结束，中间会经历各种状态变化。这些变化通常用状态转换图来表示，主要包括：
- 创建→就绪：进程创建完成后进入就绪状态
- 就绪→运行：调度程序选择进程执行
- 运行→就绪：时间片用完或更高优先级进程到达
- 运行→阻塞：进程等待某事件(如I/O操作)
- 阻塞→就绪：等待的事件发生
- 运行→终止：进程正常或异常结束

## 6. 进程有哪些状态？进程状态之间的转换（条件？操作？）
进程基本状态：
- **创建态**：进程正在被创建，尚未就绪
- **就绪态**：进程已准备好运行，等待CPU分配
- **运行态**：进程正在CPU上执行
- **阻塞态**：进程等待某事件发生而暂停执行
- **终止态**：进程执行完毕或被强制终止

状态转换：
- 创建→就绪：条件-创建工作完成；操作-插入就绪队列
- 就绪→运行：条件-被调度算法选中；操作-进程调度
- 运行→就绪：条件-时间片用完/高优先级进程到达；操作-时钟中断/抢占
- 运行→阻塞：条件-请求资源/等待事件；操作-进程自愿阻塞
- 阻塞→就绪：条件-资源可用/事件发生；操作-唤醒进程
- 运行→终止：条件-任务完成/出错/被杀；操作-释放资源

## 7. 进程状态转换的发生，是否一定导致另一个转换发生？
不一定。进程状态转换可能会触发调度程序重新评估系统中的进程，但不一定导致另一个进程的状态转换。例如：
- 当一个进程从运行态转为阻塞态时，调度程序会选择另一个就绪进程运行，此时确实导致了另一个进程从就绪态转为运行态
- 但当一个阻塞进程被唤醒转为就绪态时，如果当前运行进程的优先级更高，则不会导致任何其他进程状态的改变

状态转换是否引起连锁反应，取决于调度算法和当前系统负载情况。

## 8. 操作系统给进程提供内存空间，该空间的地址是虚拟地址还是物理地址？为什么？
操作系统给进程提供的是虚拟地址空间，而非物理地址空间。原因有：
1. **隔离保护**：每个进程拥有独立的地址空间，防止进程间相互干扰
2. **简化编程**：程序员无需考虑实际物理内存布局，可以使用连续的地址空间
3. **内存利用率**：允许程序使用比实际物理内存更大的地址空间(通过页面置换)
4. **地址重定位**：不同进程可以使用相同的虚拟地址，由MMU转换为不同的物理地址
5. **共享内存**：不同进程的虚拟地址可以映射到相同的物理内存，实现高效共享

## 9. 操作系统如何描述进程的地址空间？
操作系统通过以下方式描述进程的地址空间：
1. **页表**：在分页系统中，使用页表记录虚拟页面到物理页帧的映射关系
2. **段表**：在分段系统中，使用段表记录各段的基址和长度
3. **段页表**：在段页式系统中，结合段表和页表进行地址转换
4. **多级页表**：使用多级结构减少页表占用的内存
5. **反向页表**：以物理页帧为索引，记录哪个进程的哪个虚拟页面映射到此页帧
6. **TLB(快表)**：加速地址转换的硬件缓存

这些数据结构存储在进程的PCB中，用于地址转换和内存管理。

## 10. 为什么有了进程后又引入线程？
引入线程的主要原因：
1. **资源利用**：进程创建和切换开销大，线程共享进程资源，开销小
2. **并行效率**：多线程可以充分利用多核处理器，提高并行度
3. **响应性**：线程切换比进程切换快，提高系统响应速度
4. **通信效率**：同一进程的线程共享内存，通信更简单高效
5. **适应性**：某些应用天然适合多线程模型，如Web服务器、GUI应用等
6. **细粒度并发**：线程提供了更细粒度的并发控制

## 11. 怎样实现线程机制？为什么有各种支持线程的方式？
线程实现机制主要有三种：
1. **用户级线程(ULT)**：
   - 在用户空间实现，操作系统不感知
   - 线程库负责线程管理(创建、调度、同步等)
   - 优点：切换开销小，可移植性好
   - 缺点：一个线程阻塞会导致整个进程阻塞

2. **内核级线程(KLT)**：
   - 由操作系统内核支持和管理
   - 线程创建、调度由内核完成
   - 优点：一个线程阻塞不影响其他线程，可利用多处理器
   - 缺点：线程操作需要系统调用，开销较大

3. **混合实现**：
   - 结合用户级和内核级线程的优点
   - 多个用户级线程映射到较少的内核级线程
   - 平衡了性能和并行度

存在多种支持线程的方式，是因为不同应用场景对线程的需求不同：
- 有些应用需要大量轻量级线程(如网络服务器)
- 有些应用需要更好的实时性(如多媒体应用)
- 不同操作系统架构对线程支持方式不同
- 历史兼容性和标准化需求

## 12. 线程包Pthreads中相关的函数的功能？
Pthreads(POSIX线程)是一套标准的线程API，主要函数包括：

**线程管理**：
- `pthread_create()`: 创建新线程
- `pthread_exit()`: 终止当前线程
- `pthread_join()`: 等待指定线程结束
- `pthread_detach()`: 分离线程(结束时自动回收资源)
- `pthread_self()`: 获取当前线程ID
- `pthread_equal()`: 比较两个线程ID是否相同

**互斥与同步**：
- `pthread_mutex_init()`: 初始化互斥锁
- `pthread_mutex_lock()`: 获取互斥锁
- `pthread_mutex_unlock()`: 释放互斥锁
- `pthread_mutex_destroy()`: 销毁互斥锁
- `pthread_cond_init()`: 初始化条件变量
- `pthread_cond_wait()`: 等待条件变量
- `pthread_cond_signal()`: 唤醒等待条件的单个线程
- `pthread_cond_broadcast()`: 唤醒所有等待条件的线程

**线程属性**：
- `pthread_attr_init()`: 初始化线程属性
- `pthread_attr_setdetachstate()`: 设置线程分离状态
- `pthread_attr_setstacksize()`: 设置线程栈大小

## 13. 中断/异常机制与进程线程模型的关联？
中断/异常机制与进程线程模型的关联：

1. **进程/线程切换**：
   - 时钟中断触发调度程序执行，实现进程/线程的时间片轮转
   - 系统调用(软中断)可能导致进程阻塞和切换

2. **状态转换**：
   - I/O完成中断使阻塞进程转为就绪状态
   - 缺页异常触发页面置换，支持虚拟内存机制

3. **同步与通信**：
   - 中断处理程序可以唤醒等待特定事件的线程
   - 异常处理可以向进程发送信号

4. **保护机制**：
   - 非法访问内存产生的异常保护进程地址空间
   - 特权指令异常维护用户态和内核态的隔离

5. **资源管理**：
   - 中断处理程序负责分配和回收资源
   - 异常处理程序处理资源使用中的错误

中断/异常机制是实现进程线程模型的基础设施，提供了切换控制流、保护隔离和资源管理的能力。

## 14. 机制和策略分离的原则在进程线程模型中的体现？
机制和策略分离原则在进程线程模型中的体现：

**机制(如何做)**：
- 进程/线程创建和销毁的底层实现
- 上下文切换的硬件支持
- 地址空间隔离的内存管理单元
- 进程间通信的基本原语
- 同步互斥的底层支持(如原子操作)

**策略(做什么)**：
- 进程/线程调度算法(如优先级、时间片大小)
- 内存分配策略(如何分配物理页面)
- 负载均衡策略(如何在多核上分配线程)
- 资源分配策略(如何分配CPU时间)

这种分离的好处：
1. 提高灵活性：可以在不改变底层机制的情况下调整策略
2. 简化设计：机制和策略可以独立开发和测试
3. 适应性强：不同环境可以采用不同策略
4. 可扩展性：新策略可以基于现有机制实现

例如，Linux内核提供了完整的线程创建和调度机制，但允许通过调度类(scheduling classes)实现不同的调度策略，如完全公平调度(CFS)、实时调度等。

## 15. 协程是什么？为什么引入协程？协程怎么用？
**协程是什么**：
协程(Coroutine)是一种用户态的轻量级线程，它的调度完全由用户控制。协程可以在特定位置暂停执行(yield)，并且之后从暂停的位置继续执行，这个过程中协程的本地变量、执行状态等都会被保存。

**为什么引入协程**：
1. **高效性**：协程切换不涉及内核态切换，开销极小
2. **控制流简化**：使异步代码可以用同步方式编写，提高可读性
3. **资源节约**：可以支持大量并发任务，而无需创建同等数量的线程
4. **确定性**：协程的切换点是明确的，减少了并发错误
5. **适合I/O密集型**：在等待I/O时可以主动让出CPU，提高利用率

**协程怎么用**：
不同语言对协程的支持方式不同：

1. **Python中的协程**：
   ```python
   import asyncio
   
   async def hello():
       print("Hello")
       await asyncio.sleep(1)
       print("World")
   
   # 运行协程
   asyncio.run(hello())
   ```

2. **Go语言的goroutine**：
   ```go
   func say(s string) {
       for i := 0; i < 5; i++ {
           time.Sleep(100 * time.Millisecond)
           fmt.Println(s)
       }
   }
   
   func main() {
       go say("world")  // 启动一个goroutine
       say("hello")     // 当前goroutine执行
   }
   ```

3. **C++20协程**：
   ```cpp
   #include <coroutine>
   #include <iostream>
   
   struct Generator {
       struct promise_type {
           int value;
           auto get_return_object() { return Generator{this}; }
           auto initial_suspend() { return std::suspend_never{}; }
           auto final_suspend() noexcept { return std::suspend_always{}; }
           void return_void() {}
           void unhandled_exception() {}
           auto yield_value(int val) {
               value = val;
               return std::suspend_always{};
           }
       };
       
       // 实现细节省略
   };
   
   Generator sequence() {
       for (int i = 0; i < 10; ++i)
           co_yield i;  // 暂停并返回值
   }
   ```

协程的主要特点是协作式调度，而非抢占式调度，这使得并发控制更加精确，但也要求程序员显式地设计让出点。

## 1. 进程模型

### 1.1 基本概念

#### 1.1.1 顺序程序与顺序环境

**顺序环境的特征**：
- **程序执行的顺序性**：按照指令顺序依次执行
- **程序执行的封闭性**：独占资源，执行过程不受外界影响
- **程序执行结果的可再现性**：程序运行结果与程序执行速度无关

**程序**：指令或语句序列，体现某种算法

**顺序环境**：
- 计算机系统中只有一个程序在运行
- 该程序独占系统中的所有资源
- 该程序的执行不受外界影响

#### 1.1.2 多道程序设计（Multiprogramming）

**多道程序设计**：允许多个程序同时进入内存并运行，目的是为了提高系统效率。

#### 1.1.3 并发环境与并发程序

**并发环境**：一段时间间隔内，单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的。

**并发程序**：在并发环境中执行的程序。

**并发环境的特征**：
- 程序执行结果的不可再现性
- 程序执行的间断性：执行——停——执行
- 资源共享
- 独立性和制约性
- 程序和计算不再一一对应

#### 1.1.4 进程

**定义**：Process（又称任务Task或Job）
- 进程是对CPU的抽象
- 程序的一次执行过程
- 是正在运行程序的抽象
- 将一个CPU变换成多个虚拟的CPU
- 系统资源以进程为单位分配，如内存、文件等
- 每个进程具有独立的地址空间
- 操作系统将CPU调度给进程

进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。

**进程相关讨论**：
- **进程的作用和行为**：
  - 系统进程、用户进程
  - 前台进程、后台进程
  - CPU密集型进程、I/O密集型进程
- **进程之间的关系**：
  - UNIX进程家族树：init为根
  - Windows：地位相同
- **进程与程序的区别**：
  - 进程更能准确刻画并发，而程序不能
  - 程序是静态的，进程是动态的
  - 进程有生命周期，有诞生有消亡，是短暂的；而程序是相对长久的
  - 一个程序可对应多个进程
  - 进程具有创建其他进程的功能

### 1.2 进程模型

#### 1.2.1 进程的三种基本状态

- **运行态（Running）**：占有CPU，并在CPU上运行
- **就绪态（Ready）**：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
- **等待态（Waiting/Blocked）**：因等待某一事件（如完成I/O）而暂时不能运行，也称阻塞态、封锁态、睡眠态

#### 1.2.2 进程状态之间的转换

进程在消亡前处于且仅处于某一状态，不同系统设置的进程状态数目不同。

基本状态转换：
- 运行态 → 就绪态：时间片用完，高优先级进程就绪
- 运行态 → 阻塞态：等待某事件发生（如I/O操作）
- 就绪态 → 运行态：被调度器选中执行
- 阻塞态 → 就绪态：等待的事件发生

#### 1.2.3 进程的其他状态

1. **创建状态（new）**：
   - 已完成创建一进程所必要的工作（PID、PCB）
   - 但尚未同意执行该进程（因为资源有限）

2. **终止状态（Terminated）**：
   - 终止执行后，进程进入该状态
   - 可完成一些数据统计工作
   - 资源回收

3. **挂起状态（suspend）**：
   - 把一个进程从内存转到磁盘
   - 进程不占用内存空间，其进程映像交换到磁盘上
   - 用于调节负载

**进程状态模型**：
- 五状态进程模型：包括运行、就绪、阻塞、创建和终止
- 七状态进程模型：增加了就绪挂起和阻塞挂起状态
- Linux进程状态模型
- XV6进程状态模型：UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE

#### 1.2.4 数据结构——进程控制块PCB

**PCB（Process Control Block）**：
- 又称进程描述符、进程属性
- 操作系统中表示进程的数据结构
- 记录进程的各种属性，描述进程的动态变化过程
- 操作系统通过PCB来控制和管理进程
- 进程与PCB是一一对应的
- PCB是系统感知进程存在的唯一标志

**进程表**：所有进程的PCB的集合

**PCB主要内容**：
1. **进程描述信息**：
   - 进程标识符(process ID)，唯一，通常是一个整数
   - 进程名，通常基于可执行文件名（不唯一）
   - 用户标识符(user ID)；进程组关系
   - 进程间同步和通信；阻塞原因
   - 进程的队列指针
   - 进程的消息队列指针
   - 所拥有的资源和使用情况
   - 虚拟地址空间的现状
   - 打开文件列表

2. **进程控制信息**：
   - 当前状态
   - 优先级(priority)
   - CPU现场信息(context)
   - 代码执行入口地址
   - 寄存器值（通用、程序计数器PC、状态PSW，地址如栈指针）
   - 可执行文件名（磁盘地址）
   - 指向赋予该进程的段/页表的指针
   - 运行统计信息（执行时间页面调度）

**实例**：
- Solaris的进程控制块与进程表
- Linux的task_struct结构
- XV6的PCB

#### 1.2.5 进程地址空间

操作系统给每个进程都分配了一个地址空间，地址空间是对内存的抽象。

**进程地址空间组成**：
- 栈（Stack）：函数调用、局部变量
- 堆（Heap）：动态内存分配
- 数据段（Data）：全局变量、静态变量
- 代码段（Code）：程序指令

进程地址空间是虚拟的，通过内存管理单元（MMU）映射到物理内存。

**进程生成示意**：
1. 源代码文件编译链接成可执行文件
2. 加载到内存形成进程地址空间
3. 包括代码、数据、堆、栈等部分

**地址空间访问**：
- 可以通过`/proc/PID/maps`查看进程的内存映射情况
- 进程间的地址空间是相互隔离的，即使地址相同也指向不同的物理内存

#### 1.2.6 进程表(队列)

操作系统为每一类进程建立一个或多个队列，队列元素为PCB。伴随进程状态的改变，其PCB从一个队列进入另一个队列。

**队列类型**：
- 就绪队列：等待CPU调度的进程
- 等待队列：等待特定事件的进程（可以有多个等待队列，对应不同事件）
- 运行队列：正在运行的进程（单CPU情况下，只有一个进程）

### 1.3 进程控制

**原语（primitive）**：完成某种特定功能的一段程序，具有不可分割性或不可中断性，即原语的执行必须是连续的，在执行过程中不允许被中断。也称为原子操作（atomic）。

进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成：
- 进程创建原语
- 进程撤销原语
- 阻塞原语
- 唤醒原语
- 挂起原语
- 激活（解挂）原语
- 改变进程优先级原语

#### 1.3.1 进程何时创建和终止

**进程创建时机**：
- 系统初始化时
- 操作系统提供的服务
- 交互用户登录系统
- 由现有的进程派生出一个新进程
- 提交一个程序执行（例如，命令行）

**进程终止时机**：
- 正常退出（自愿的）
- 出错退出（自愿的）
- 严重错误（非自愿）
- 被其他进程杀死（非自愿）

**导致进程终止的各种事件**：
- 正常结束
- 给定时限到
- 缺少内存
- 存储器出界
- 保护性出错（写只读文件）
- 算术错
- 超出时间（进程等待超过对某事件的最大值）
- I/O 失败
- 无效指令（如试图执行数据）
- 特权指令
- 操作系统干预（如当死锁发生时）
- 父进程请求中止某一子进程
- 父进程中止（子进程也中止）

#### 1.3.2 进程的创建

进程创建主要完成以下工作：
1. 给新进程分配一个唯一标识(pid)以及进程控制块(PCB)
2. 为进程分配地址空间
3. 初始化进程控制块
   - 设置默认值（如：状态为New等）
   - 设置相应的队列指针
4. 创建或扩充其他数据结构

在UNIX系统中，使用fork()创建进程；在Windows中，使用CreateProcess()创建进程。

#### 1.3.3 进程的撤销

进程撤销主要完成以下工作：
1. 结束子进程或线程
2. 收回进程所占有的资源
   - 关闭打开的文件
   - 断开网络连接
   - 回收分配的内存等
3. 撤销该进程的PCB

在UNIX系统中，使用exit()终止进程；在Windows中，使用ExitProcess()终止进程。

#### 1.3.4 进程阻塞和进程唤醒

处于运行状态的进程，在其运行过程中期待某一事件发生（如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息），当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。

在UNIX系统中，使用wait()实现进程阻塞；在Windows中，使用WaitForSingleObject()实现进程阻塞。

#### 1.3.5 UNIX系统设计的进程控制操作

- **fork()**：通过复制调用进程来建立新的进程，是最基本的进程建立过程
- **exec()**：包括一系列系统调用，它们都是通过用一段新的代码覆盖原来的内存空间，实现进程执行代码的转换
- **wait()**：提供初级的进程同步措施，能使一个进程等待，直到另外一个进程结束为止
- **exit()**：用来终止一个进程的运行

**UNIX的fork()实现**：
1. 为子进程分配一个空闲的进程描述符
2. 分配给子进程唯一标识pid
3. 以一次一页的方式复制父进程地址空间
4. 从父进程处继承共享资源，如打开的文件和当前工作目录等
5. 将子进程的状态设为就绪，插入到就绪队列
6. 对子进程返回标识符0
7. 对父进程返回子进程的pid

**Copy-on-Write（写时复制）技术**：
Linux利用存储管理模块中的"写时复制技术"(COW)对fork()进行了优化。fork()后，父子进程共享相同的物理页面，这些页面被标记为只读。当任一进程尝试修改页面内容时，才会创建该页面的副本。

## 2. 线程模型

### 2.1 线程的引入

**为什么在进程中再派生线程？**
1. 应用的需要
2. 开销的考虑
3. 性能的考虑——多核、多处理器

#### 2.1.1 应用的需要

**示例1：有三个线程的字处理软件**
- 一个线程处理用户输入
- 一个线程负责检查拼写和语法
- 一个线程负责页面布局和格式化

这种设计能提高响应速度，使用户体验更加流畅。

**示例2：Web服务器**
- 工作原理：
  - 从客户端接收网页请求
  - 从磁盘上检索相关
